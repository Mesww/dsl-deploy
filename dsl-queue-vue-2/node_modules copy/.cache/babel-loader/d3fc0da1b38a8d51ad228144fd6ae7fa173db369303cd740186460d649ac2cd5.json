{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nlet Declaration = require('./declaration');\nlet tokenizer = require('./tokenize');\nlet Comment = require('./comment');\nlet AtRule = require('./at-rule');\nlet Root = require('./root');\nlet Rule = require('./rule');\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n};\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i];\n    let pos = token[3] || token[2];\n    if (pos) return pos;\n  }\n}\nclass Parser {\n  constructor(input) {\n    this.input = input;\n    this.root = new Root();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input,\n      start: {\n        column: 1,\n        line: 1,\n        offset: 0\n      }\n    };\n  }\n  atrule(token) {\n    let node = new AtRule();\n    node.name = token[1].slice(1);\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n    this.init(node, token[2]);\n    let type;\n    let prev;\n    let shift;\n    let last = false;\n    let open = false;\n    let params = [];\n    let brackets = [];\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      type = token[0];\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}');\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n      }\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2]);\n          node.source.end.offset++;\n          this.semicolon = true;\n          break;\n        } else if (type === '{') {\n          open = true;\n          break;\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1;\n            prev = params[shift];\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift];\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2]);\n              node.source.end.offset++;\n            }\n          }\n          this.end(token);\n          break;\n        } else {\n          params.push(token);\n        }\n      } else {\n        params.push(token);\n      }\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = this.getPosition(token[3] || token[2]);\n        node.source.end.offset++;\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  }\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens);\n    if (colon === false) return;\n    let founded = 0;\n    let token;\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);\n  }\n  colon(tokens) {\n    let brackets = 0;\n    let token, type, prev;\n    for (let [i, element] of tokens.entries()) {\n      token = element;\n      type = token[0];\n      if (type === '(') {\n        brackets += 1;\n      }\n      if (type === ')') {\n        brackets -= 1;\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n      prev = token;\n    }\n    return false;\n  }\n  comment(token) {\n    let node = new Comment();\n    this.init(node, token[2]);\n    node.source.end = this.getPosition(token[3] || token[2]);\n    node.source.end.offset++;\n    let text = token[1].slice(2, -2);\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  }\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input);\n  }\n  decl(tokens, customProperty) {\n    let node = new Declaration();\n    this.init(node, tokens[0][2]);\n    let last = tokens[tokens.length - 1];\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n    node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n    node.source.end.offset++;\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n    node.source.start = this.getPosition(tokens[0][2]);\n    node.prop = '';\n    while (tokens.length) {\n      let type = tokens[0][0];\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n      node.prop += tokens.shift()[1];\n    }\n    node.raws.between = '';\n    let token;\n    while (tokens.length) {\n      token = tokens.shift();\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n        node.raws.between += token[1];\n      }\n    }\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n    let firstSpaces = [];\n    let next;\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      firstSpaces.push(tokens.shift());\n    }\n    this.precheckMissedSemicolon(tokens);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        let string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0);\n        let str = '';\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0];\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break;\n          }\n          str = cache.pop()[1] + str;\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment');\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('');\n      firstSpaces = [];\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens);\n    }\n  }\n  doubleColon(token) {\n    throw this.input.error('Double colon', {\n      offset: token[2]\n    }, {\n      offset: token[2] + token[1].length\n    });\n  }\n  emptyRule(token) {\n    let node = new Rule();\n    this.init(node, token[2]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  }\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2]);\n      this.current.source.end.offset++;\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  }\n  endFile() {\n    if (this.current.parent) this.unclosedBlock();\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.root.source.end = this.getPosition(this.tokenizer.position());\n  }\n  freeSemicolon(token) {\n    this.spaces += token[1];\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1];\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset);\n    return {\n      column: pos.col,\n      line: pos.line,\n      offset\n    };\n  }\n  init(node, offset) {\n    this.current.push(node);\n    node.source = {\n      input: this.input,\n      start: this.getPosition(offset)\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  }\n  other(start) {\n    let end = false;\n    let type = null;\n    let colon = false;\n    let bracket = null;\n    let brackets = [];\n    let customProperty = start[1].startsWith('--');\n    let tokens = [];\n    let token = start;\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token;\n        brackets.push('}');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n      token = this.tokenizer.nextToken();\n    }\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0];\n          if (token !== 'space' && token !== 'comment') break;\n          this.tokenizer.back(tokens.pop());\n        }\n      }\n      this.decl(tokens, customProperty);\n    } else {\n      this.unknownWord(tokens);\n    }\n  }\n  parse() {\n    let token;\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n        case ';':\n          this.freeSemicolon(token);\n          break;\n        case '}':\n          this.end(token);\n          break;\n        case 'comment':\n          this.comment(token);\n          break;\n        case 'at-word':\n          this.atrule(token);\n          break;\n        case '{':\n          this.emptyRule(token);\n          break;\n        default:\n          this.other(token);\n          break;\n      }\n    }\n    this.endFile();\n  }\n  precheckMissedSemicolon( /* tokens */\n  ) {\n    // Hook for Safe Parser\n  }\n  raw(node, prop, tokens, customProperty) {\n    let token, type;\n    let length = tokens.length;\n    let value = '';\n    let clean = true;\n    let next, prev;\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false;\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false;\n          } else {\n            value += token[1];\n          }\n        } else {\n          clean = false;\n        }\n      } else {\n        value += token[1];\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '');\n      node.raws[prop] = {\n        raw,\n        value\n      };\n    }\n    node[prop] = value;\n  }\n  rule(tokens) {\n    tokens.pop();\n    let node = new Rule();\n    this.init(node, tokens[0][2]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  }\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  }\n\n  // Errors\n\n  spacesAndCommentsFromStart(tokens) {\n    let next;\n    let spaces = '';\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n    return spaces;\n  }\n  spacesFromEnd(tokens) {\n    let lastTokenType;\n    let spaces = '';\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n    return spaces;\n  }\n  stringFrom(tokens, from) {\n    let result = '';\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n    tokens.splice(from, tokens.length - from);\n    return result;\n  }\n  unclosedBlock() {\n    let pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  }\n  unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', {\n      offset: bracket[2]\n    }, {\n      offset: bracket[2] + 1\n    });\n  }\n  unexpectedClose(token) {\n    throw this.input.error('Unexpected }', {\n      offset: token[2]\n    }, {\n      offset: token[2] + 1\n    });\n  }\n  unknownWord(tokens) {\n    throw this.input.error('Unknown word', {\n      offset: tokens[0][2]\n    }, {\n      offset: tokens[0][2] + tokens[0][1].length\n    });\n  }\n  unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', {\n      offset: token[2]\n    }, {\n      offset: token[2] + token[1].length\n    });\n  }\n}\nmodule.exports = Parser;","map":{"version":3,"names":["require","Declaration","tokenizer","Comment","AtRule","Root","Rule","SAFE_COMMENT_NEIGHBOR","empty","space","findLastWithPosition","tokens","i","length","token","pos","Parser","constructor","input","root","current","spaces","semicolon","createTokenizer","source","start","column","line","offset","atrule","node","name","slice","unnamedAtrule","init","type","prev","shift","last","open","params","brackets","endOfFile","nextToken","push","pop","end","getPosition","raws","between","spacesAndCommentsFromEnd","afterName","spacesAndCommentsFromStart","raw","nodes","checkMissedSemicolon","colon","founded","j","error","element","entries","doubleColon","comment","text","test","left","right","match","decl","customProperty","unknownWord","before","prop","firstSpaces","next","precheckMissedSemicolon","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","trim","indexOf","hasWord","some","map","join","concat","value","includes","emptyRule","selector","after","parent","unexpectedClose","endFile","unclosedBlock","position","freeSemicolon","ownSemicolon","fromOffset","col","other","bracket","startsWith","rule","back","unclosedBracket","parse","clean","reduce","all","lastTokenType","from","result","splice","module","exports"],"sources":["/home/worawut_kni/Work/dsl-queue-vue-2/node_modules/postcss/lib/parser.js"],"sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet tokenizer = require('./tokenize')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nconst SAFE_COMMENT_NEIGHBOR = {\n  empty: true,\n  space: true\n}\n\nfunction findLastWithPosition(tokens) {\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i]\n    let pos = token[3] || token[2]\n    if (pos) return pos\n  }\n}\n\nclass Parser {\n  constructor(input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }\n  }\n\n  atrule(token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2])\n\n    let type\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n    let brackets = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n      type = token[0]\n\n      if (type === '(' || type === '[') {\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (type === '{' && brackets.length > 0) {\n        brackets.push('}')\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n      }\n\n      if (brackets.length === 0) {\n        if (type === ';') {\n          node.source.end = this.getPosition(token[2])\n          node.source.end.offset++\n          this.semicolon = true\n          break\n        } else if (type === '{') {\n          open = true\n          break\n        } else if (type === '}') {\n          if (params.length > 0) {\n            shift = params.length - 1\n            prev = params[shift]\n            while (prev && prev[0] === 'space') {\n              prev = params[--shift]\n            }\n            if (prev) {\n              node.source.end = this.getPosition(prev[3] || prev[2])\n              node.source.end.offset++\n            }\n          }\n          this.end(token)\n          break\n        } else {\n          params.push(token)\n        }\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = this.getPosition(token[3] || token[2])\n        node.source.end.offset++\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  checkMissedSemicolon(tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.\n    // Then we need to return the colon after that word token. [3] is the \"end\" colon of that word.\n    // And because we need it after that one we do +1 to get the next one.\n    throw this.input.error(\n      'Missed semicolon',\n      token[0] === 'word' ? token[3] + 1 : token[2]\n    )\n  }\n\n  colon(tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let [i, element] of tokens.entries()) {\n      token = element\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  comment(token) {\n    let node = new Comment()\n    this.init(node, token[2])\n    node.source.end = this.getPosition(token[3] || token[2])\n    node.source.end.offset++\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  createTokenizer() {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  decl(tokens, customProperty) {\n    let node = new Declaration()\n    this.init(node, tokens[0][2])\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n\n    node.source.end = this.getPosition(\n      last[3] || last[2] || findLastWithPosition(tokens)\n    )\n    node.source.end.offset++\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = this.getPosition(tokens[0][2])\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n\n    let firstSpaces = []\n    let next\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      firstSpaces.push(tokens.shift())\n    }\n\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')\n\n    if (hasWord) {\n      node.raws.between += firstSpaces.map(i => i[1]).join('')\n      firstSpaces = []\n    }\n    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)\n\n    if (node.value.includes(':') && !customProperty) {\n      this.checkMissedSemicolon(tokens)\n    }\n  }\n\n  doubleColon(token) {\n    throw this.input.error(\n      'Double colon',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n\n  emptyRule(token) {\n    let node = new Rule()\n    this.init(node, token[2])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = this.getPosition(token[2])\n      this.current.source.end.offset++\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile() {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.root.source.end = this.getPosition(this.tokenizer.position())\n  }\n\n  freeSemicolon(token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  getPosition(offset) {\n    let pos = this.input.fromOffset(offset)\n    return {\n      column: pos.col,\n      line: pos.line,\n      offset\n    }\n  }\n\n  init(node, offset) {\n    this.current.push(node)\n    node.source = {\n      input: this.input,\n      start: this.getPosition(offset)\n    }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  other(start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n    let customProperty = start[1].startsWith('--')\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (customProperty && colon && type === '{') {\n        if (!bracket) bracket = token\n        brackets.push('}')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens, customProperty)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      if (!customProperty) {\n        while (tokens.length) {\n          token = tokens[tokens.length - 1][0]\n          if (token !== 'space' && token !== 'comment') break\n          this.tokenizer.back(tokens.pop())\n        }\n      }\n      this.decl(tokens, customProperty)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  parse() {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  precheckMissedSemicolon(/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  raw(node, prop, tokens, customProperty) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n      if (type === 'space' && i === length - 1 && !customProperty) {\n        clean = false\n      } else if (type === 'comment') {\n        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'\n        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'\n        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n          if (value.slice(-1) === ',') {\n            clean = false\n          } else {\n            value += token[1]\n          }\n        } else {\n          clean = false\n        }\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { raw, value }\n    }\n    node[prop] = value\n  }\n\n  rule(tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  spacesAndCommentsFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  // Errors\n\n  spacesAndCommentsFromStart(tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd(tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom(tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  unclosedBlock() {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  unclosedBracket(bracket) {\n    throw this.input.error(\n      'Unclosed bracket',\n      { offset: bracket[2] },\n      { offset: bracket[2] + 1 }\n    )\n  }\n\n  unexpectedClose(token) {\n    throw this.input.error(\n      'Unexpected }',\n      { offset: token[2] },\n      { offset: token[2] + 1 }\n    )\n  }\n\n  unknownWord(tokens) {\n    throw this.input.error(\n      'Unknown word',\n      { offset: tokens[0][2] },\n      { offset: tokens[0][2] + tokens[0][1].length }\n    )\n  }\n\n  unnamedAtrule(node, token) {\n    throw this.input.error(\n      'At-rule without name',\n      { offset: token[2] },\n      { offset: token[2] + token[1].length }\n    )\n  }\n}\n\nmodule.exports = Parser\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}