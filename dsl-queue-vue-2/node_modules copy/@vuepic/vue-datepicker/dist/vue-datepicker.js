import { openBlock as $, createElementBlock as j, createElementVNode as ce, unref as i, reactive as zt, computed as Q, ref as ee, toRef as Lt, watch as mt, h as Ln, render as qa, defineComponent as Ee, renderSlot as se, createCommentVNode as X, normalizeClass as Me, withKeys as fe, createBlock as we, withModifiers as $e, nextTick as et, onMounted as He, onUnmounted as na, normalizeProps as Ie, mergeProps as Ne, Fragment as ke, normalizeStyle as qe, createTextVNode as it, toDisplayString as Ve, onBeforeUpdate as Vn, renderList as Pe, withDirectives as xt, vShow as ea, withCtx as ye, createVNode as Xe, Transition as _t, createSlots as We, useSlots as Dt, guardReactiveProps as ze, resolveDynamicComponent as la, getCurrentScope as Wn, onScopeDispose as Hn, isRef as Xa, Teleport as zn } from "vue";
import { format as lt, isEqual as Tt, setHours as dn, setMinutes as cn, setSeconds as Ya, setMilliseconds as Ia, isAfter as St, getYear as pe, getMonth as he, setMonth as Un, setYear as nt, addMonths as kt, subMonths as Vt, isValid as ta, isBefore as Wt, set as Ae, eachDayOfInterval as fn, getHours as xe, getMinutes as rt, getSeconds as Pt, startOfWeek as Na, endOfWeek as vn, parse as _a, isDate as Kn, addHours as jn, addYears as mn, subYears as pn, addDays as bt, getDay as Gn, differenceInCalendarDays as Qn, add as gn, sub as qn, getWeek as Xn, getISOWeek as Jn, isSameQuarter as Ja, eachQuarterOfInterval as Zn, startOfYear as xn, endOfYear as el, startOfQuarter as tl, endOfQuarter as Za, getQuarter as xa } from "date-fns";
function Ot() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      ce("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ce("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      ce("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Ot.compatConfig = {
  MODE: 3
};
function yn() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      ce("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
yn.compatConfig = {
  MODE: 3
};
function Ea() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Ea.compatConfig = {
  MODE: 3
};
function Fa() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Fa.compatConfig = {
  MODE: 3
};
function La() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      ce("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
La.compatConfig = {
  MODE: 3
};
function Va() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Va.compatConfig = {
  MODE: 3
};
function Wa() {
  return $(), j(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      ce("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Wa.compatConfig = {
  MODE: 3
};
const ot = (e, t) => t ? new Date(e.toLocaleString("en-US", { timeZone: t })) : new Date(e), hn = (e, t) => {
  const r = Oa(e, t);
  return r || z();
}, al = (e, t) => t.dateInTz ? ot(new Date(e), t.dateInTz) : z(e), Oa = (e, t) => {
  if (!e)
    return null;
  if (!t)
    return z(e);
  const r = z(e);
  return t.exactMatch ? al(e, t) : ot(r, t.timezone);
}, nl = (e) => {
  if (!e)
    return 0;
  const t = /* @__PURE__ */ new Date(), r = new Date(t.toLocaleString("en-US", { timeZone: "UTC" })), n = new Date(t.toLocaleString("en-US", { timeZone: e })), a = n.getTimezoneOffset() / 60;
  return (+r - +n) / (1e3 * 60 * 60) - a;
};
function en(e) {
  return (t) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`)).slice(0, 2);
}
function ll(e) {
  return (t) => lt(/* @__PURE__ */ new Date(`2017-01-0${t}T00:00:00+00:00`), "EEEEEE", { locale: e });
}
const rl = (e, t, r) => {
  const n = [1, 2, 3, 4, 5, 6, 7];
  let a;
  if (e !== null)
    try {
      a = n.map(ll(e));
    } catch {
      a = n.map(en(t));
    }
  else
    a = n.map(en(t));
  const f = a.slice(0, r), v = a.slice(r + 1, a.length);
  return [a[r]].concat(...v).concat(...f);
}, Ha = (e, t, r) => {
  const n = [];
  for (let a = +e[0]; a <= +e[1]; a++)
    n.push({ value: +a, text: Mn(a, t) });
  return r ? n.reverse() : n;
}, bn = (e, t, r) => {
  const n = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((f) => {
    const v = f < 10 ? `0${f}` : f;
    return /* @__PURE__ */ new Date(`2017-${v}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const f = r === "long" ? "MMMM" : "MMM";
      return n.map((v, s) => {
        const C = lt(ot(v, "UTC"), f, { locale: e });
        return {
          text: C.charAt(0).toUpperCase() + C.substring(1),
          value: s
        };
      });
    } catch {
    }
  const a = new Intl.DateTimeFormat(t, { month: r, timeZone: "UTC" });
  return n.map((f, v) => {
    const s = a.format(f);
    return {
      text: s.charAt(0).toUpperCase() + s.substring(1),
      value: v
    };
  });
}, ol = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Ye = (e) => {
  const t = i(e);
  return t != null && t.$el ? t == null ? void 0 : t.$el : t;
}, sl = (e) => ({ type: "dot", ...e ?? {} }), kn = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, za = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Be = (e) => e, tn = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, an = (e) => e === null, wn = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, ul = (e) => {
  const t = [], r = (n) => n.filter((a) => a);
  for (let n = 0; n < e.length; n += 3) {
    const a = [e[n], e[n + 1], e[n + 2]];
    t.push(r(a));
  }
  return t;
}, Ht = (e, t, r) => {
  const n = r != null, a = t != null;
  if (!n && !a)
    return !1;
  const f = +r, v = +t;
  return n && a ? +e > f || +e < v : n ? +e > f : a ? +e < v : !1;
}, Rt = (e, t) => ul(e).map((r) => r.map((n) => {
  const { active: a, disabled: f, isBetween: v, highlighted: s } = t(n);
  return {
    ...n,
    active: a,
    disabled: f,
    className: {
      dp__overlay_cell_active: a,
      dp__overlay_cell: !a,
      dp__overlay_cell_disabled: f,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: f && a,
      dp__cell_in_between: v,
      "dp--highlighted": s
    }
  };
})), ft = (e, t, r = !1) => {
  e && t.allowStopPropagation && (r && e.stopImmediatePropagation(), e.stopPropagation());
}, il = () => [
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "[tabindex]:not([tabindex='-1'])",
  "[data-datepicker-instance]"
].join(", ");
function dl(e, t) {
  let r = [...document.querySelectorAll(il())];
  r = r.filter((a) => !e.contains(a) || a.hasAttribute("data-datepicker-instance"));
  const n = r.indexOf(e);
  if (n >= 0 && (t ? n - 1 >= 0 : n + 1 <= r.length))
    return r[n + (t ? -1 : 1)];
}
const cl = (e, t) => e == null ? void 0 : e.querySelector(`[data-dp-element="${t}"]`), Mn = (e, t) => new Intl.NumberFormat(t, { useGrouping: !1, style: "decimal" }).format(e), Ua = (e) => lt(e, "dd-MM-yyyy"), ka = (e) => Array.isArray(e), aa = (e, t) => t.get(Ua(e)), fl = (e, t) => e ? t ? t instanceof Map ? !!aa(e, t) : t(z(e)) : !1 : !0, nn = (e, t, r, n, a, f) => {
  const v = _a(e, t.slice(0, e.length), /* @__PURE__ */ new Date(), { locale: f });
  return ta(v) && Kn(v) ? n || a ? v : Ae(v, {
    hours: +r.hours,
    minutes: +(r == null ? void 0 : r.minutes),
    seconds: +(r == null ? void 0 : r.seconds),
    milliseconds: 0
  }) : null;
}, vl = (e, t, r, n, a, f) => {
  const v = Array.isArray(r) ? r[0] : r;
  if (typeof t == "string")
    return nn(e, t, v, n, a, f);
  if (Array.isArray(t)) {
    let s = null;
    for (const C of t)
      if (s = nn(e, C, v, n, a, f), s)
        break;
    return s;
  }
  return typeof t == "function" ? t(e) : null;
}, z = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), ml = (e, t, r) => {
  if (t) {
    const a = (e.getMonth() + 1).toString().padStart(2, "0"), f = e.getDate().toString().padStart(2, "0"), v = e.getHours().toString().padStart(2, "0"), s = e.getMinutes().toString().padStart(2, "0"), C = r ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${a}-${f}T${v}:${s}:${C}.000Z`;
  }
  const n = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(n).toISOString();
}, Qe = (e) => {
  let t = z(JSON.parse(JSON.stringify(e)));
  return t = dn(t, 0), t = cn(t, 0), t = Ya(t, 0), t = Ia(t, 0), t;
}, vt = (e, t, r, n) => {
  let a = e ? z(e) : z();
  return (t || t === 0) && (a = dn(a, +t)), (r || r === 0) && (a = cn(a, +r)), (n || n === 0) && (a = Ya(a, +n)), Ia(a, 0);
}, Ce = (e, t) => !e || !t ? !1 : Wt(Qe(e), Qe(t)), be = (e, t) => !e || !t ? !1 : Tt(Qe(e), Qe(t)), Oe = (e, t) => !e || !t ? !1 : St(Qe(e), Qe(t)), ra = (e, t, r) => e != null && e[0] && (e != null && e[1]) ? Oe(r, e[0]) && Ce(r, e[1]) : e != null && e[0] && t ? Oe(r, e[0]) && Ce(r, t) || Ce(r, e[0]) && Oe(r, t) : !1, Ze = (e) => {
  const t = Ae(new Date(e), { date: 1 });
  return Qe(t);
}, wa = (e, t, r) => t && (r || r === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((n) => n === t ? [n, r] : [n, isNaN(+e[n]) ? void 0 : +e[n]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, wt = (e) => ({
  hours: xe(e),
  minutes: rt(e),
  seconds: Pt(e)
}), Dn = (e, t) => {
  if (t) {
    const r = pe(z(t));
    if (r > e)
      return 12;
    if (r === e)
      return he(z(t));
  }
}, $n = (e, t) => {
  if (t) {
    const r = pe(z(t));
    return r < e ? -1 : r === e ? he(z(t)) : void 0;
  }
}, Ct = (e) => {
  if (e)
    return pe(z(e));
}, An = (e, t) => {
  const r = Oe(e, t) ? t : e, n = Oe(t, e) ? t : e;
  return fn({ start: r, end: n });
}, pl = (e) => {
  const t = kt(e, 1);
  return { month: he(t), year: pe(t) };
}, st = (e, t) => {
  const r = Na(e, { weekStartsOn: +t }), n = vn(e, { weekStartsOn: +t });
  return [r, n];
}, Tn = (e, t) => {
  const r = {
    hours: xe(z()),
    minutes: rt(z()),
    seconds: t ? Pt(z()) : 0
  };
  return Object.assign(r, e);
}, ct = (e, t, r) => [Ae(z(e), { date: 1 }), Ae(z(), { month: t, year: r, date: 1 })], ut = (e, t, r) => {
  let n = e ? z(e) : z();
  return (t || t === 0) && (n = Un(n, t)), r && (n = nt(n, r)), n;
}, Sn = (e, t, r, n, a) => {
  if (!n || a && !t || !a && !r)
    return !1;
  const f = a ? kt(e, 1) : Vt(e, 1), v = [he(f), pe(f)];
  return a ? !yl(...v, t) : !gl(...v, r);
}, gl = (e, t, r) => Ce(...ct(r, e, t)) || be(...ct(r, e, t)), yl = (e, t, r) => Oe(...ct(r, e, t)) || be(...ct(r, e, t)), Pn = (e, t, r, n, a, f, v) => {
  if (typeof t == "function" && !v)
    return t(e);
  const s = r ? { locale: r } : void 0;
  return Array.isArray(e) ? `${lt(e[0], f, s)}${a && !e[1] ? "" : n}${e[1] ? lt(e[1], f, s) : ""}` : lt(e, f, s);
}, $t = (e) => {
  if (e)
    return null;
  throw new Error(za.prop("partial-range"));
}, Jt = (e, t) => {
  if (t)
    return e();
  throw new Error(za.prop("range"));
}, Ba = (e) => Array.isArray(e) ? ta(e[0]) && (e[1] ? ta(e[1]) : !0) : e ? ta(e) : !1, hl = (e, t) => Ae(t ?? z(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), Ma = (e, t, r, n) => {
  if (!e)
    return !0;
  if (n) {
    const a = r === "max" ? Wt(e, t) : St(e, t), f = { seconds: 0, milliseconds: 0 };
    return a || Tt(Ae(e, f), Ae(t, f));
  }
  return r === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime();
}, Da = (e, t, r) => e ? hl(e, t) : z(r ?? t), ln = (e, t, r, n, a) => {
  if (Array.isArray(n)) {
    const v = Da(e, n[0], t), s = Da(e, n[1], t);
    return Ma(n[0], v, r, !!t) && Ma(n[1], s, r, !!t) && a;
  }
  const f = Da(e, n, t);
  return Ma(n, f, r, !!t) && a;
}, $a = (e) => Ae(z(), wt(e)), bl = (e, t) => e instanceof Map ? Array.from(e.values()).filter((r) => pe(z(r)) === t).map((r) => he(r)) : [], Rn = (e, t, r) => typeof e == "function" ? e({ month: t, year: r }) : !!e.months.find((n) => n.month === t && n.year === r), Ka = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t), Et = zt({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), Cn = () => {
  const e = (n) => {
    Et.menuFocused = n;
  }, t = (n) => {
    Et.shiftKeyInMenu !== n && (Et.shiftKeyInMenu = n);
  };
  return {
    control: Q(() => ({ shiftKeyInMenu: Et.shiftKeyInMenu, menuFocused: Et.menuFocused })),
    setMenuFocused: e,
    setShiftKey: t
  };
}, Se = zt({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Aa = ee(null), Zt = ee(!1), Ta = ee(!1), Sa = ee(!1), Pa = ee(!1), Le = ee(0), _e = ee(0), pt = () => {
  const e = Q(() => Zt.value ? [...Se.selectionGrid, Se.actionRow].filter((b) => b.length) : Ta.value ? [
    ...Se.timePicker[0],
    ...Se.timePicker[1],
    Pa.value ? [] : [Aa.value],
    Se.actionRow
  ].filter((b) => b.length) : Sa.value ? [...Se.monthPicker, Se.actionRow] : [Se.monthYear, ...Se.calendar, Se.time, Se.actionRow].filter((b) => b.length)), t = (b) => {
    Le.value = b ? Le.value + 1 : Le.value - 1;
    let L = null;
    e.value[_e.value] && (L = e.value[_e.value][Le.value]), !L && e.value[_e.value + (b ? 1 : -1)] ? (_e.value = _e.value + (b ? 1 : -1), Le.value = b ? 0 : e.value[_e.value].length - 1) : L || (Le.value = b ? Le.value - 1 : Le.value + 1);
  }, r = (b) => {
    if (_e.value === 0 && !b || _e.value === e.value.length && b)
      return;
    _e.value = b ? _e.value + 1 : _e.value - 1, e.value[_e.value] ? e.value[_e.value] && !e.value[_e.value][Le.value] && Le.value !== 0 && (Le.value = e.value[_e.value].length - 1) : _e.value = b ? _e.value - 1 : _e.value + 1;
  }, n = (b) => {
    let L = null;
    e.value[_e.value] && (L = e.value[_e.value][Le.value]), L ? L.focus({ preventScroll: !Zt.value }) : Le.value = b ? Le.value - 1 : Le.value + 1;
  }, a = () => {
    t(!0), n(!0);
  }, f = () => {
    t(!1), n(!1);
  }, v = () => {
    r(!1), n(!0);
  }, s = () => {
    r(!0), n(!0);
  }, C = (b, L) => {
    Se[L] = b;
  }, B = (b, L) => {
    Se[L] = b;
  }, h = () => {
    Le.value = 0, _e.value = 0;
  };
  return {
    buildMatrix: C,
    buildMultiLevelMatrix: B,
    setTimePickerBackRef: (b) => {
      Aa.value = b;
    },
    setSelectionGrid: (b) => {
      Zt.value = b, h(), b || (Se.selectionGrid = []);
    },
    setTimePicker: (b, L = !1) => {
      Ta.value = b, Pa.value = L, h(), b || (Se.timePicker[0] = [], Se.timePicker[1] = []);
    },
    setTimePickerElements: (b, L = 0) => {
      Se.timePicker[L] = b;
    },
    arrowRight: a,
    arrowLeft: f,
    arrowUp: v,
    arrowDown: s,
    clearArrowNav: () => {
      Se.monthYear = [], Se.calendar = [], Se.time = [], Se.actionRow = [], Se.selectionGrid = [], Se.timePicker[0] = [], Se.timePicker[1] = [], Zt.value = !1, Ta.value = !1, Pa.value = !1, Sa.value = !1, h(), Aa.value = null;
    },
    setMonthPicker: (b) => {
      Sa.value = b, h();
    },
    refSets: Se
    // exposed for testing
  };
}, rn = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), kl = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (t) => `Increment ${t}`,
  decrementValue: (t) => `Decrement ${t}`,
  openTpOverlay: (t) => `Open ${t} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  ...e ?? {}
}), on = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, wl = (e) => {
  const t = typeof e == "object" && e, r = {
    static: !0,
    solo: !1
  };
  if (!e)
    return { ...r, count: on(!1) };
  const n = t ? e : {}, a = t ? n.count ?? !0 : e, f = on(a);
  return Object.assign(r, n, { count: f });
}, Ml = (e, t, r) => e || (typeof r == "string" ? r : t), Dl = (e) => typeof e == "boolean" ? e ? rn({}) : !1 : rn(e), $l = (e) => {
  const t = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: !0,
    selectOnFocus: !1,
    rangeSeparator: " - "
  };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : { ...t, enabled: e };
}, Al = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), Tl = (e) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...e ?? {}
}), Sl = (e) => {
  const t = { input: !1 };
  return typeof e == "object" ? { ...t, ...e ?? {}, enabled: !0 } : {
    enabled: e,
    ...t
  };
}, Pl = (e) => ({ ...{
  allowStopPropagation: !0,
  closeOnScroll: !1,
  modeHeight: 255,
  allowPreventDefault: !1,
  closeOnClearValue: !0,
  closeOnAutoApply: !0,
  noSwipe: !1,
  keepActionRow: !1,
  onClickOutside: void 0,
  tabOutClosesMenu: !0,
  arrowLeft: void 0,
  keepViewOnOffsetClick: !1
}, ...e ?? {} }), Rl = (e) => {
  const t = {
    dates: Array.isArray(e) ? e.map((r) => z(r)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: [],
    options: { highlightDisabled: !1 }
  };
  return typeof e == "function" ? e : { ...t, ...e ?? {} };
}, Cl = (e) => typeof e == "object" ? {
  type: (e == null ? void 0 : e.type) ?? "local",
  hideOnOffsetDates: (e == null ? void 0 : e.hideOnOffsetDates) ?? !1
} : {
  type: e,
  hideOnOffsetDates: !1
}, _l = (e, t) => {
  const r = {
    noDisabledRange: !1,
    showLastInRange: !0,
    minMaxRawRange: !1,
    partialRange: !0,
    disableTimeRangeValidation: !1,
    maxRange: void 0,
    minRange: void 0,
    autoRange: void 0,
    fixedStart: !1,
    fixedEnd: !1
  };
  return typeof e == "object" ? { enabled: !0, ...r, ...e } : {
    enabled: e,
    noDisabledRange: t.noDisabledRange,
    showLastInRange: t.showLastInRange,
    minMaxRawRange: t.minMaxRawRange,
    partialRange: t.partialRange,
    disableTimeRangeValidation: t.disableTimeRangeValidation,
    maxRange: t.maxRange,
    minRange: t.minRange,
    autoRange: t.autoRange,
    fixedStart: t.fixedStart,
    fixedEnd: t.fixedEnd
  };
}, Ol = (e, t) => e ? typeof e == "string" ? { timezone: e, exactMatch: !1, dateInTz: void 0, emitTimezone: t, convertModel: !0 } : {
  timezone: e.timezone,
  exactMatch: e.exactMatch ?? !1,
  dateInTz: e.dateInTz ?? void 0,
  emitTimezone: t ?? e.emitTimezone,
  convertModel: e.convertModel ?? !0
} : { timezone: void 0, exactMatch: !1, emitTimezone: t }, Ra = (e, t) => new Map(
  e.map((r) => {
    const n = hn(r, t);
    return [Ua(n), n];
  })
), Bl = (e, t) => e.length ? new Map(
  e.map((r) => {
    const n = hn(r.date, t);
    return [Ua(n), r];
  })
) : null, Yl = (e, t, r, n, a, f, v) => ({
  minDate: Oa(e, v),
  maxDate: Oa(t, v),
  disabledDates: ka(r) ? Ra(r, v) : r,
  allowedDates: ka(n) ? Ra(n, v) : null,
  highlight: typeof a == "object" && ka(a == null ? void 0 : a.dates) ? Ra(a.dates, v) : a,
  markers: Bl(f, v)
}), Il = (e, t) => typeof e == "boolean" ? { enabled: e, dragSelect: !0, limit: +t } : {
  enabled: !!e,
  limit: e.limit ? +e.limit : null,
  dragSelect: e.dragSelect ?? !0
}, Re = (e) => {
  const t = () => {
    const F = e.enableSeconds ? ":ss" : "", Y = e.enableMinutes ? ":mm" : "";
    return e.is24 ? `HH${Y}${F}` : `hh${Y}${F} aa`;
  }, r = () => {
    var F;
    return e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${((F = I.value) == null ? void 0 : F.type) === "iso" ? "RR" : "ww"}-yyyy` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy";
  }, n = (F) => Tn(F, e.enableSeconds), a = () => q.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [n(e.startTime[0]), n(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? n(e.startTime) : null, f = Q(() => wl(e.multiCalendars)), v = Q(() => a()), s = Q(() => kl(e.ariaLabels)), C = Q(() => Al(e.filters)), B = Q(() => Dl(e.transitions)), h = Q(() => Tl(e.actionRow)), w = Q(
    () => Ml(e.previewFormat, e.format, r())
  ), k = Q(() => $l(e.textInput)), _ = Q(() => Sl(e.inline)), U = Q(() => Pl(e.config)), S = Q(() => Rl(e.highlight)), I = Q(() => Cl(e.weekNumbers)), b = Q(() => Ol(e.timezone, e.emitTimezone)), L = Q(() => Il(e.multiDates, e.multiDatesLimit)), N = Q(
    () => Yl(
      e.minDate,
      e.maxDate,
      e.disabledDates,
      e.allowedDates,
      S.value,
      e.markers,
      b.value
    )
  ), q = Q(
    () => _l(e.range, {
      minMaxRawRange: !1,
      maxRange: e.maxRange,
      minRange: e.minRange,
      noDisabledRange: e.noDisabledRange,
      showLastInRange: e.showLastInRange,
      partialRange: e.partialRange,
      disableTimeRangeValidation: e.disableTimeRangeValidation,
      autoRange: e.autoRange,
      fixedStart: e.fixedStart,
      fixedEnd: e.fixedEnd
    })
  );
  return {
    defaultedTransitions: B,
    defaultedMultiCalendars: f,
    defaultedStartTime: v,
    defaultedAriaLabels: s,
    defaultedFilters: C,
    defaultedActionRow: h,
    defaultedPreviewFormat: w,
    defaultedTextInput: k,
    defaultedInline: _,
    defaultedConfig: U,
    defaultedHighlight: S,
    defaultedWeekNumbers: I,
    defaultedRange: q,
    propDates: N,
    defaultedTz: b,
    defaultedMultiDates: L,
    getDefaultPattern: r,
    getDefaultStartTime: a
  };
};
var Je = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(Je || {}), ht = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(ht || {}), Mt = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(Mt || {}), at = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(at || {});
const Nl = ["timestamp", "date", "iso"], El = (e, t, r) => {
  const n = ee(), { defaultedTextInput: a, defaultedRange: f, defaultedTz: v, defaultedMultiDates: s, getDefaultPattern: C } = Re(t), B = ee(""), h = Lt(t, "format"), w = Lt(t, "formatLocale");
  mt(
    n,
    () => {
      typeof t.onInternalModelChange == "function" && e("internal-model-change", n.value, R(!0));
    },
    { deep: !0 }
  ), mt(h, () => {
    p();
  });
  const k = (d) => v.value.timezone && v.value.convertModel ? ot(d, v.value.timezone) : d, _ = (d) => {
    if (v.value.timezone && v.value.convertModel) {
      const le = nl(v.value.timezone);
      return jn(d, le);
    }
    return d;
  }, U = (d, le, l = !1) => Pn(
    d,
    t.format,
    t.formatLocale,
    a.value.rangeSeparator,
    t.modelAuto,
    le ?? C(),
    l
  ), S = (d) => d ? t.modelType ? E(d) : {
    hours: xe(d),
    minutes: rt(d),
    seconds: t.enableSeconds ? Pt(d) : 0
  } : null, I = (d) => t.modelType ? E(d) : { month: he(d), year: pe(d) }, b = (d) => Array.isArray(d) ? s.value.enabled ? d.map((le) => L(le, nt(z(), le))) : Jt(
    () => [
      nt(z(), d[0]),
      d[1] ? nt(z(), d[1]) : $t(f.value.partialRange)
    ],
    f.value.enabled
  ) : nt(z(), +d), L = (d, le) => (typeof d == "string" || typeof d == "number") && t.modelType ? J(d) : le, N = (d) => Array.isArray(d) ? [
    L(
      d[0],
      vt(null, +d[0].hours, +d[0].minutes, d[0].seconds)
    ),
    L(
      d[1],
      vt(null, +d[1].hours, +d[1].minutes, d[1].seconds)
    )
  ] : L(d, vt(null, d.hours, d.minutes, d.seconds)), q = (d) => {
    const le = Ae(z(), { date: 1 });
    return Array.isArray(d) ? s.value.enabled ? d.map((l) => L(l, ut(le, +l.month, +l.year))) : Jt(
      () => [
        L(d[0], ut(le, +d[0].month, +d[0].year)),
        L(
          d[1],
          d[1] ? ut(le, +d[1].month, +d[1].year) : $t(f.value.partialRange)
        )
      ],
      f.value.enabled
    ) : L(d, ut(le, +d.month, +d.year));
  }, F = (d) => {
    if (Array.isArray(d))
      return d.map((le) => J(le));
    throw new Error(za.dateArr("multi-dates"));
  }, Y = (d) => {
    if (Array.isArray(d) && f.value.enabled) {
      const le = d[0], l = d[1];
      return [
        z(Array.isArray(le) ? le[0] : null),
        z(Array.isArray(l) ? l[0] : null)
      ];
    }
    return z(d[0]);
  }, K = (d) => t.modelAuto ? Array.isArray(d) ? [J(d[0]), J(d[1])] : t.autoApply ? [J(d)] : [J(d), null] : Array.isArray(d) ? Jt(
    () => d[1] ? [
      J(d[0]),
      d[1] ? J(d[1]) : $t(f.value.partialRange)
    ] : [J(d[0])],
    f.value.enabled
  ) : J(d), y = () => {
    Array.isArray(n.value) && f.value.enabled && n.value.length === 1 && n.value.push($t(f.value.partialRange));
  }, ie = () => {
    const d = n.value;
    return [
      E(d[0]),
      d[1] ? E(d[1]) : $t(f.value.partialRange)
    ];
  }, oe = () => n.value[1] ? ie() : E(Be(n.value[0])), re = () => (n.value || []).map((d) => E(d)), O = (d = !1) => (d || y(), t.modelAuto ? oe() : s.value.enabled ? re() : Array.isArray(n.value) ? Jt(() => ie(), f.value.enabled) : E(Be(n.value))), W = (d) => !d || Array.isArray(d) && !d.length ? null : t.timePicker ? N(Be(d)) : t.monthPicker ? q(Be(d)) : t.yearPicker ? b(Be(d)) : s.value.enabled ? F(Be(d)) : t.weekPicker ? Y(Be(d)) : K(Be(d)), te = (d) => {
    const le = W(d);
    Ba(Be(le)) ? (n.value = Be(le), p()) : (n.value = null, B.value = "");
  }, V = () => {
    const d = (le) => lt(le, a.value.format);
    return `${d(n.value[0])} ${a.value.rangeSeparator} ${n.value[1] ? d(n.value[1]) : ""}`;
  }, c = () => r.value && n.value ? Array.isArray(n.value) ? V() : lt(n.value, a.value.format) : U(n.value), T = () => n.value ? s.value.enabled ? n.value.map((d) => U(d)).join("; ") : a.value.enabled && typeof a.value.format == "string" ? c() : U(n.value) : "", p = () => {
    !t.format || typeof t.format == "string" || a.value.enabled && typeof a.value.format == "string" ? B.value = T() : B.value = t.format(n.value);
  }, J = (d) => {
    if (t.utc) {
      const le = new Date(d);
      return t.utc === "preserve" ? new Date(le.getTime() + le.getTimezoneOffset() * 6e4) : le;
    }
    return t.modelType ? Nl.includes(t.modelType) ? k(new Date(d)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? k(
      _a(d, C(), /* @__PURE__ */ new Date(), { locale: w.value })
    ) : k(
      _a(d, t.modelType, /* @__PURE__ */ new Date(), { locale: w.value })
    ) : k(new Date(d));
  }, E = (d) => d ? t.utc ? ml(d, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +_(d) : t.modelType === "iso" ? _(d).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? U(_(d)) : U(_(d), t.modelType, !0) : _(d) : "", m = (d, le = !1, l = !1) => {
    if (l)
      return d;
    if (e("update:model-value", d), v.value.emitTimezone && le) {
      const P = Array.isArray(d) ? d.map((x) => ot(Be(x), v.value.emitTimezone)) : ot(Be(d), v.value.emitTimezone);
      e("update:model-timezone-value", P);
    }
  }, H = (d) => Array.isArray(n.value) ? s.value.enabled ? n.value.map((le) => d(le)) : [
    d(n.value[0]),
    n.value[1] ? d(n.value[1]) : $t(f.value.partialRange)
  ] : d(Be(n.value)), ne = () => {
    if (Array.isArray(n.value)) {
      const d = st(n.value[0], t.weekStart), le = n.value[1] ? st(n.value[1], t.weekStart) : [];
      return [d.map((l) => z(l)), le.map((l) => z(l))];
    }
    return st(n.value, t.weekStart).map((d) => z(d));
  }, u = (d, le) => m(Be(H(d)), !1, le), M = (d) => {
    const le = ne();
    return d ? le : e("update:model-value", ne());
  }, R = (d = !1) => (d || p(), t.monthPicker ? u(I, d) : t.timePicker ? u(S, d) : t.yearPicker ? u(pe, d) : t.weekPicker ? M(d) : m(O(d), !0, d));
  return {
    inputValue: B,
    internalModelValue: n,
    checkBeforeEmit: () => n.value ? f.value.enabled ? f.value.partialRange ? n.value.length >= 1 : n.value.length === 2 : !!n.value : !1,
    parseExternalModelValue: te,
    formatInputValue: p,
    emitModelValue: R
  };
}, Fl = (e, t) => {
  const { defaultedFilters: r, propDates: n } = Re(e), { validateMonthYearInRange: a } = gt(e), f = (h, w) => {
    let k = h;
    return r.value.months.includes(he(k)) ? (k = w ? kt(h, 1) : Vt(h, 1), f(k, w)) : k;
  }, v = (h, w) => {
    let k = h;
    return r.value.years.includes(pe(k)) ? (k = w ? mn(h, 1) : pn(h, 1), v(k, w)) : k;
  }, s = (h, w = !1) => {
    const k = Ae(z(), { month: e.month, year: e.year });
    let _ = h ? kt(k, 1) : Vt(k, 1);
    e.disableYearSelect && (_ = nt(_, e.year));
    let U = he(_), S = pe(_);
    r.value.months.includes(U) && (_ = f(_, h), U = he(_), S = pe(_)), r.value.years.includes(S) && (_ = v(_, h), S = pe(_)), a(U, S, h, e.preventMinMaxNavigation) && C(U, S, w);
  }, C = (h, w, k) => {
    t("update-month-year", { month: h, year: w, fromNav: k });
  }, B = Q(() => (h) => Sn(
    Ae(z(), { month: e.month, year: e.year }),
    n.value.maxDate,
    n.value.minDate,
    e.preventMinMaxNavigation,
    h
  ));
  return { handleMonthYearChange: s, isDisabled: B, updateMonthYear: C };
};
var At = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(At || {});
const Ll = ({
  menuRef: e,
  menuRefInner: t,
  inputRef: r,
  pickerWrapperRef: n,
  inline: a,
  emit: f,
  props: v,
  slots: s
}) => {
  const C = ee({}), B = ee(!1), h = ee({
    top: "0",
    left: "0"
  }), w = ee(!1), k = Lt(v, "teleportCenter");
  mt(k, () => {
    h.value = JSON.parse(JSON.stringify({})), q();
  });
  const _ = (c) => {
    if (v.teleport) {
      const T = c.getBoundingClientRect();
      return {
        left: T.left + window.scrollX,
        top: T.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, U = (c, T) => {
    h.value.left = `${c + T - C.value.width}px`;
  }, S = (c) => {
    h.value.left = `${c}px`;
  }, I = (c, T) => {
    v.position === At.left && S(c), v.position === At.right && U(c, T), v.position === At.center && (h.value.left = `${c + T / 2 - C.value.width / 2}px`);
  }, b = (c) => {
    const { width: T, height: p } = c.getBoundingClientRect(), { top: J, left: E } = v.altPosition ? v.altPosition(c) : _(c);
    return { top: +J, left: +E, width: T, height: p };
  }, L = () => {
    h.value.left = "50%", h.value.top = "50%", h.value.transform = "translate(-50%, -50%)", h.value.position = "fixed", delete h.value.opacity;
  }, N = () => {
    const c = Ye(r), { top: T, left: p, transform: J } = v.altPosition(c);
    h.value = { top: `${T}px`, left: `${p}px`, transform: J ?? "" };
  }, q = (c = !0) => {
    var T;
    if (!a.value.enabled) {
      if (k.value)
        return L();
      if (v.altPosition !== null)
        return N();
      if (c) {
        const p = v.teleport ? (T = t.value) == null ? void 0 : T.$el : e.value;
        p && (C.value = p.getBoundingClientRect()), f("recalculate-position");
      }
      return re();
    }
  }, F = ({ inputEl: c, left: T, width: p }) => {
    window.screen.width > 768 && !B.value && I(T, p), y(c);
  }, Y = (c) => {
    const { top: T, left: p, height: J, width: E } = b(c);
    h.value.top = `${J + T + +v.offset}px`, w.value = !1, B.value || (h.value.left = `${p + E / 2 - C.value.width / 2}px`), F({ inputEl: c, left: p, width: E });
  }, K = (c) => {
    const { top: T, left: p, width: J } = b(c);
    h.value.top = `${T - +v.offset - C.value.height}px`, w.value = !0, F({ inputEl: c, left: p, width: J });
  }, y = (c) => {
    if (v.autoPosition) {
      const { left: T, width: p } = b(c), { left: J, right: E } = C.value;
      if (!B.value) {
        if (Math.abs(J) !== Math.abs(E)) {
          if (J <= 0)
            return B.value = !0, S(T);
          if (E >= document.documentElement.clientWidth)
            return B.value = !0, U(T, p);
        }
        return I(T, p);
      }
    }
  }, ie = () => {
    const c = Ye(r);
    if (c) {
      const { height: T } = C.value, { top: p, height: J } = c.getBoundingClientRect(), m = window.innerHeight - p - J, H = p;
      return T <= m ? ht.bottom : T > m && T <= H ? ht.top : m >= H ? ht.bottom : ht.top;
    }
    return ht.bottom;
  }, oe = (c) => ie() === ht.bottom ? Y(c) : K(c), re = () => {
    const c = Ye(r);
    if (c)
      return v.autoPosition ? oe(c) : Y(c);
  }, O = function(c) {
    if (c) {
      const T = c.scrollHeight > c.clientHeight, J = window.getComputedStyle(c).overflowY.indexOf("hidden") !== -1;
      return T && !J;
    }
    return !0;
  }, W = function(c) {
    return !c || c === document.body || c.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : O(c) ? c : W(c.assignedSlot ? c.assignedSlot.parentNode : c.parentNode);
  }, te = (c) => {
    if (c)
      switch (v.position) {
        case At.left:
          return { left: 0, transform: "translateX(0)" };
        case At.right:
          return { left: `${c.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${c.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: w,
    menuStyle: h,
    xCorrect: B,
    setMenuPosition: q,
    getScrollableParent: W,
    shadowRender: (c, T) => {
      var ne, u, M;
      const p = document.createElement("div"), J = (ne = Ye(r)) == null ? void 0 : ne.getBoundingClientRect();
      p.setAttribute("id", "dp--temp-container");
      const E = (u = n.value) != null && u.clientWidth ? n.value : document.body;
      E.append(p);
      const m = te(J), H = Ln(
        c,
        {
          ...T,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...m }
        },
        Object.fromEntries(
          Object.keys(s).filter((R) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(R)).map((R) => [R, s[R]])
        )
      );
      qa(H, p), C.value = (M = H.el) == null ? void 0 : M.getBoundingClientRect(), qa(null, p), E.removeChild(p);
    }
  };
}, dt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] }
], Vl = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Wl = {
  all: () => dt,
  monthYear: () => dt.filter((e) => e.use.includes("month-year")),
  input: () => Vl,
  timePicker: () => dt.filter((e) => e.use.includes("time")),
  action: () => dt.filter((e) => e.use.includes("action")),
  calendar: () => dt.filter((e) => e.use.includes("calendar")),
  menu: () => dt.filter((e) => e.use.includes("menu")),
  shared: () => dt.filter((e) => e.use.includes("shared")),
  yearMode: () => dt.filter((e) => e.use.includes("year-mode"))
}, Ge = (e, t, r) => {
  const n = [];
  return Wl[t]().forEach((a) => {
    e[a.name] && n.push(a.name);
  }), r != null && r.length && r.forEach((a) => {
    a.slot && n.push(a.slot);
  }), n;
}, Ut = (e) => {
  const t = Q(() => (n) => e.value ? n ? e.value.open : e.value.close : ""), r = Q(() => (n) => e.value ? n ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: t, showTransition: !!e.value, menuTransition: r };
}, Kt = (e, t) => {
  const { defaultedRange: r, defaultedTz: n } = Re(e), a = z(ot(z(), n.value.timezone)), f = ee([{ month: he(a), year: pe(a) }]), v = zt({
    hours: r.value.enabled ? [xe(a), xe(a)] : xe(a),
    minutes: r.value.enabled ? [rt(a), rt(a)] : rt(a),
    seconds: r.value.enabled ? [0, 0] : 0
  }), s = Q({
    get: () => e.internalModelValue,
    set: (h) => {
      !e.readonly && !e.disabled && t("update:internal-model-value", h);
    }
  }), C = Q(
    () => (h) => f.value[h] ? f.value[h].month : 0
  ), B = Q(
    () => (h) => f.value[h] ? f.value[h].year : 0
  );
  return {
    calendars: f,
    time: v,
    modelValue: s,
    month: C,
    year: B,
    today: a
  };
}, Hl = (e, t) => {
  const { defaultedMultiCalendars: r, defaultedMultiDates: n, defaultedHighlight: a, defaultedTz: f, propDates: v, defaultedRange: s } = Re(t), { isDisabled: C } = gt(t), B = ee(null), h = ee(ot(/* @__PURE__ */ new Date(), f.value.timezone)), w = (u) => {
    !u.current && t.hideOffsetDates || (B.value = u.value);
  }, k = () => {
    B.value = null;
  }, _ = (u) => Array.isArray(e.value) && s.value.enabled && e.value[0] && B.value ? u ? Oe(B.value, e.value[0]) : Ce(B.value, e.value[0]) : !0, U = (u, M) => {
    const R = () => e.value ? M ? e.value[0] || null : e.value[1] : null, de = e.value && Array.isArray(e.value) ? R() : null;
    return be(z(u.value), de);
  }, S = (u) => {
    const M = Array.isArray(e.value) ? e.value[0] : null;
    return u ? !Ce(B.value ?? null, M) : !0;
  }, I = (u, M = !0) => (s.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !u.current ? !1 : be(z(u.value), e.value[M ? 0 : 1]) : s.value.enabled ? U(u, M) && S(M) || be(u.value, Array.isArray(e.value) ? e.value[0] : null) && _(M) : !1, b = (u, M) => {
    if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
      const R = be(u.value, B.value);
      return M ? Oe(e.value[0], u.value) && R : Ce(e.value[0], u.value) && R;
    }
    return !1;
  }, L = (u) => !e.value || t.hideOffsetDates && !u.current ? !1 : s.value.enabled ? t.modelAuto && Array.isArray(e.value) ? be(u.value, e.value[0] ? e.value[0] : h.value) : !1 : n.value.enabled && Array.isArray(e.value) ? e.value.some((M) => be(M, u.value)) : be(u.value, e.value ? e.value : h.value), N = (u) => {
    if (s.value.autoRange || t.weekPicker) {
      if (B.value) {
        if (t.hideOffsetDates && !u.current)
          return !1;
        const M = bt(B.value, +s.value.autoRange), R = st(z(B.value), t.weekStart);
        return t.weekPicker ? be(R[1], z(u.value)) : be(M, z(u.value));
      }
      return !1;
    }
    return !1;
  }, q = (u) => {
    if (s.value.autoRange || t.weekPicker) {
      if (B.value) {
        const M = bt(B.value, +s.value.autoRange);
        if (t.hideOffsetDates && !u.current)
          return !1;
        const R = st(z(B.value), t.weekStart);
        return t.weekPicker ? Oe(u.value, R[0]) && Ce(u.value, R[1]) : Oe(u.value, B.value) && Ce(u.value, M);
      }
      return !1;
    }
    return !1;
  }, F = (u) => {
    if (s.value.autoRange || t.weekPicker) {
      if (B.value) {
        if (t.hideOffsetDates && !u.current)
          return !1;
        const M = st(z(B.value), t.weekStart);
        return t.weekPicker ? be(M[0], u.value) : be(B.value, u.value);
      }
      return !1;
    }
    return !1;
  }, Y = (u) => ra(e.value, B.value, u.value), K = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : !1, y = () => t.modelAuto ? kn(t.internalModelValue) : !0, ie = (u) => {
    if (t.weekPicker)
      return !1;
    const M = s.value.enabled ? !I(u) && !I(u, !1) : !0;
    return !C(u.value) && !L(u) && !(!u.current && t.hideOffsetDates) && M;
  }, oe = (u) => s.value.enabled ? t.modelAuto ? K() && L(u) : !1 : L(u), re = (u) => a.value ? fl(u.value, v.value.highlight) : !1, O = (u) => {
    const M = C(u.value);
    return M && (typeof a.value == "function" ? !a.value(u.value, M) : !a.value.options.highlightDisabled);
  }, W = (u) => {
    var M;
    return typeof a.value == "function" ? a.value(u.value) : (M = a.value.weekdays) == null ? void 0 : M.includes(u.value.getDay());
  }, te = (u) => (s.value.enabled || t.weekPicker) && (!(r.value.count > 0) || u.current) && y() && !(!u.current && t.hideOffsetDates) && !L(u) ? Y(u) : !1, V = (u) => {
    const { isRangeStart: M, isRangeEnd: R } = J(u), de = s.value.enabled ? M || R : !1;
    return {
      dp__cell_offset: !u.current,
      dp__pointer: !t.disabled && !(!u.current && t.hideOffsetDates) && !C(u.value),
      dp__cell_disabled: C(u.value),
      dp__cell_highlight: !O(u) && (re(u) || W(u)) && !oe(u) && !de && !F(u) && !(te(u) && t.weekPicker) && !R,
      dp__cell_highlight_active: !O(u) && (re(u) || W(u)) && oe(u),
      dp__today: !t.noToday && be(u.value, h.value) && u.current,
      "dp--past": Ce(u.value, h.value),
      "dp--future": Oe(u.value, h.value)
    };
  }, c = (u) => ({
    dp__active_date: oe(u),
    dp__date_hover: ie(u)
  }), T = (u) => {
    if (e.value && !Array.isArray(e.value)) {
      const M = st(e.value, t.weekStart);
      return {
        ...m(u),
        dp__range_start: be(M[0], u.value),
        dp__range_end: be(M[1], u.value),
        dp__range_between_week: Oe(u.value, M[0]) && Ce(u.value, M[1])
      };
    }
    return {
      ...m(u)
    };
  }, p = (u) => {
    if (e.value && Array.isArray(e.value)) {
      const M = st(e.value[0], t.weekStart), R = e.value[1] ? st(e.value[1], t.weekStart) : [];
      return {
        ...m(u),
        dp__range_start: be(M[0], u.value) || be(R[0], u.value),
        dp__range_end: be(M[1], u.value) || be(R[1], u.value),
        dp__range_between_week: Oe(u.value, M[0]) && Ce(u.value, M[1]) || Oe(u.value, R[0]) && Ce(u.value, R[1]),
        dp__range_between: Oe(u.value, M[1]) && Ce(u.value, R[0])
      };
    }
    return {
      ...m(u)
    };
  }, J = (u) => {
    const M = r.value.count > 0 ? u.current && I(u) && y() : I(u) && y(), R = r.value.count > 0 ? u.current && I(u, !1) && y() : I(u, !1) && y();
    return { isRangeStart: M, isRangeEnd: R };
  }, E = (u) => {
    const { isRangeStart: M, isRangeEnd: R } = J(u);
    return {
      dp__range_start: M,
      dp__range_end: R,
      dp__range_between: te(u),
      dp__date_hover: be(u.value, B.value) && !M && !R && !t.weekPicker,
      dp__date_hover_start: b(u, !0),
      dp__date_hover_end: b(u, !1)
    };
  }, m = (u) => ({
    ...E(u),
    dp__cell_auto_range: q(u),
    dp__cell_auto_range_start: F(u),
    dp__cell_auto_range_end: N(u)
  }), H = (u) => s.value.enabled ? s.value.autoRange ? m(u) : t.modelAuto ? { ...c(u), ...E(u) } : t.weekPicker ? p(u) : E(u) : t.weekPicker ? T(u) : c(u);
  return {
    setHoverDate: w,
    clearHoverDate: k,
    getDayClassData: (u) => t.hideOffsetDates && !u.current ? {} : {
      ...V(u),
      ...H(u),
      [t.dayClass ? t.dayClass(u.value) : ""]: !0,
      [t.calendarCellClassName]: !!t.calendarCellClassName
    }
  };
}, gt = (e) => {
  const { defaultedFilters: t, defaultedRange: r, propDates: n, defaultedMultiDates: a } = Re(e), f = (O) => n.value.disabledDates ? typeof n.value.disabledDates == "function" ? n.value.disabledDates(z(O)) : !!aa(O, n.value.disabledDates) : !1, v = (O) => {
    const W = n.value.maxDate ? Oe(O, n.value.maxDate) : !1, te = n.value.minDate ? Ce(O, n.value.minDate) : !1, V = f(O), T = t.value.months.map((H) => +H).includes(he(O)), p = e.disabledWeekDays.length ? e.disabledWeekDays.some((H) => +H === Gn(O)) : !1, J = w(O), E = pe(O), m = E < +e.yearRange[0] || E > +e.yearRange[1];
    return !(W || te || V || T || m || p || J);
  }, s = (O, W) => Ce(...ct(n.value.minDate, O, W)) || be(...ct(n.value.minDate, O, W)), C = (O, W) => Oe(...ct(n.value.maxDate, O, W)) || be(...ct(n.value.maxDate, O, W)), B = (O, W, te) => {
    let V = !1;
    return n.value.maxDate && te && C(O, W) && (V = !0), n.value.minDate && !te && s(O, W) && (V = !0), V;
  }, h = (O, W, te, V) => {
    let c = !1;
    return V ? n.value.minDate && n.value.maxDate ? c = B(O, W, te) : (n.value.minDate && s(O, W) || n.value.maxDate && C(O, W)) && (c = !0) : c = !0, c;
  }, w = (O) => Array.isArray(n.value.allowedDates) && !n.value.allowedDates.length ? !0 : n.value.allowedDates ? !aa(O, n.value.allowedDates) : !1, k = (O) => !v(O), _ = (O) => r.value.noDisabledRange ? !fn({ start: O[0], end: O[1] }).some((te) => k(te)) : !0, U = (O) => {
    if (O) {
      const W = pe(O);
      return W >= +e.yearRange[0] && W <= e.yearRange[1];
    }
    return !0;
  }, S = (O, W) => !!(Array.isArray(O) && O[W] && (r.value.maxRange || r.value.minRange) && U(O[W])), I = (O, W, te = 0) => {
    if (S(W, te) && U(O)) {
      const V = Qn(O, W[te]), c = An(W[te], O), T = c.length === 1 ? 0 : c.filter((J) => k(J)).length, p = Math.abs(V) - (r.value.minMaxRawRange ? 0 : T);
      if (r.value.minRange && r.value.maxRange)
        return p >= +r.value.minRange && p <= +r.value.maxRange;
      if (r.value.minRange)
        return p >= +r.value.minRange;
      if (r.value.maxRange)
        return p <= +r.value.maxRange;
    }
    return !0;
  }, b = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, L = (O) => Array.isArray(O) ? [O[0] ? $a(O[0]) : null, O[1] ? $a(O[1]) : null] : $a(O), N = (O, W, te) => O.find(
    (V) => +V.hours === xe(W) && V.minutes === "*" ? !0 : +V.minutes === rt(W) && +V.hours === xe(W)
  ) && te, q = (O, W, te) => {
    const [V, c] = O, [T, p] = W;
    return !N(V, T, te) && !N(c, p, te) && te;
  }, F = (O, W) => {
    const te = Array.isArray(W) ? W : [W];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? q(e.disabledTimes, te, O) : !te.some((V) => N(e.disabledTimes, V, O)) : O;
  }, Y = (O, W) => {
    const te = Array.isArray(W) ? [wt(W[0]), W[1] ? wt(W[1]) : void 0] : wt(W), V = !e.disabledTimes(te);
    return O && V;
  }, K = (O, W) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? F(W, O) : Y(W, O) : W, y = (O) => {
    let W = !0;
    if (!O || b())
      return !0;
    const te = !n.value.minDate && !n.value.maxDate ? L(O) : O;
    return (e.maxTime || n.value.maxDate) && (W = ln(
      e.maxTime,
      n.value.maxDate,
      "max",
      Be(te),
      W
    )), (e.minTime || n.value.minDate) && (W = ln(
      e.minTime,
      n.value.minDate,
      "min",
      Be(te),
      W
    )), K(O, W);
  }, ie = (O) => {
    if (!e.monthPicker)
      return !0;
    let W = !0;
    const te = z(Ze(O));
    if (n.value.minDate && n.value.maxDate) {
      const V = z(Ze(n.value.minDate)), c = z(Ze(n.value.maxDate));
      return Oe(te, V) && Ce(te, c) || be(te, V) || be(te, c);
    }
    if (n.value.minDate) {
      const V = z(Ze(n.value.minDate));
      W = Oe(te, V) || be(te, V);
    }
    if (n.value.maxDate) {
      const V = z(Ze(n.value.maxDate));
      W = Ce(te, V) || be(te, V);
    }
    return W;
  }, oe = Q(() => (O) => !e.enableTimePicker || e.ignoreTimeValidation ? !0 : y(O)), re = Q(() => (O) => e.monthPicker ? Array.isArray(O) && (r.value.enabled || a.value.enabled) ? !O.filter((te) => !ie(te)).length : ie(O) : !0);
  return {
    isDisabled: k,
    validateDate: v,
    validateMonthYearInRange: h,
    isDateRangeAllowed: _,
    checkMinMaxRange: I,
    isValidTime: y,
    isTimeValid: oe,
    isMonthValid: re
  };
}, oa = () => {
  const e = Q(() => (n, a) => n == null ? void 0 : n.includes(a)), t = Q(() => (n, a) => n.count ? n.solo ? !0 : a === 0 : !0), r = Q(() => (n, a) => n.count ? n.solo ? !0 : a === n.count - 1 : !0);
  return { hideNavigationButtons: e, showLeftIcon: t, showRightIcon: r };
}, zl = (e, t, r) => {
  const n = ee(0), a = zt({
    [Mt.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [Mt.calendar]: !1,
    [Mt.header]: !1
  }), f = Q(() => e.monthPicker || e.timePicker), v = (w) => {
    var k;
    if ((k = e.flow) != null && k.length) {
      if (!w && f.value)
        return h();
      a[w] = !0, Object.keys(a).filter((_) => !a[_]).length || h();
    }
  }, s = () => {
    var w;
    (w = e.flow) != null && w.length && n.value !== -1 && (n.value += 1, t("flow-step", n.value), h());
  }, C = () => {
    n.value = -1;
  }, B = (w, k, ..._) => {
    var U, S;
    e.flow[n.value] === w && r.value && ((S = (U = r.value)[k]) == null || S.call(U, ..._));
  }, h = () => {
    B(at.month, "toggleMonthPicker", !0), B(at.year, "toggleYearPicker", !0), B(at.calendar, "toggleTimePicker", !1, !0), B(at.time, "toggleTimePicker", !0, !0);
    const w = e.flow[n.value];
    (w === at.hours || w === at.minutes || w === at.seconds) && B(w, "toggleTimePicker", !0, !0, w);
  };
  return { childMount: v, updateFlowStep: s, resetFlow: C, flowStep: n };
}, sa = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: Boolean, default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: [String, Object], default: null },
  emitTimezone: { type: String, default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Function, Object],
    default: null
  },
  teleport: { type: [Boolean, String, Object], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function, Object],
    default: null
  },
  calendarClassName: { type: String, default: null },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: [Object, Boolean], default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: [Boolean, Object], default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  noDisabledRange: { type: Boolean, default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  showLastInRange: { type: Boolean, default: !0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: !1 },
  yearFirst: { type: Boolean, default: !1 },
  loading: { type: Boolean, default: !1 },
  onInternalModelChange: { type: [Function, Object], default: null },
  enableMinutes: { type: Boolean, default: !0 }
}, tt = {
  ...sa,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  noOverlayFocus: { type: Boolean, default: !1 },
  collapse: { type: Boolean, default: !1 },
  menuWrapRef: { type: Object, default: null },
  getInputRect: { type: Function, default: () => ({}) }
}, Ul = {
  key: 1,
  class: "dp__input_wrap"
}, Kl = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"], jl = {
  key: 2,
  class: "dp__clear_icon"
}, Gl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...sa
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, {
      defaultedTextInput: f,
      defaultedAriaLabels: v,
      defaultedInline: s,
      defaultedConfig: C,
      defaultedRange: B,
      defaultedMultiDates: h,
      getDefaultPattern: w,
      getDefaultStartTime: k
    } = Re(a), { checkMinMaxRange: _ } = gt(a), U = ee(), S = ee(null), I = ee(!1), b = ee(!1), L = Q(
      () => ({
        dp__pointer: !a.disabled && !a.readonly && !f.value.enabled,
        dp__disabled: a.disabled,
        dp__input_readonly: !f.value.enabled,
        dp__input: !0,
        dp__input_icon_pad: !a.hideInputIcon,
        dp__input_valid: !!a.state,
        dp__input_invalid: a.state === !1,
        dp__input_focus: I.value || a.isMenuOpen,
        dp__input_reg: !f.value.enabled,
        [a.inputClassName]: !!a.inputClassName
      })
    ), N = () => {
      n("set-input-date", null), a.clearable && a.autoApply && (n("set-empty-date"), U.value = null);
    }, q = (p) => {
      const J = k();
      return vl(
        p,
        f.value.format ?? w(),
        J ?? Tn({}, a.enableSeconds),
        a.inputValue,
        b.value,
        a.formatLocale
      );
    }, F = (p) => {
      const { rangeSeparator: J } = f.value, [E, m] = p.split(`${J}`);
      if (E) {
        const H = q(E.trim()), ne = m ? q(m.trim()) : null;
        if (St(H, ne))
          return;
        const u = H && ne ? [H, ne] : [H];
        _(ne, u, 0) && (U.value = H ? u : null);
      }
    }, Y = () => {
      b.value = !0;
    }, K = (p) => {
      if (B.value.enabled)
        F(p);
      else if (h.value.enabled) {
        const J = p.split(";");
        U.value = J.map((E) => q(E.trim())).filter((E) => E);
      } else
        U.value = q(p);
    }, y = (p) => {
      var E;
      const J = typeof p == "string" ? p : (E = p.target) == null ? void 0 : E.value;
      J !== "" ? (f.value.openMenu && !a.isMenuOpen && n("open"), K(J), n("set-input-date", U.value)) : N(), b.value = !1, n("update:input-value", J);
    }, ie = (p) => {
      f.value.enabled ? (K(p.target.value), f.value.enterSubmit && Ba(U.value) && a.inputValue !== "" ? (n("set-input-date", U.value, !0), U.value = null) : f.value.enterSubmit && a.inputValue === "" && (U.value = null, n("clear"))) : O(p);
    }, oe = (p) => {
      f.value.enabled && f.value.tabSubmit && K(p.target.value), f.value.tabSubmit && Ba(U.value) && a.inputValue !== "" ? (n("set-input-date", U.value, !0, !0), U.value = null) : f.value.tabSubmit && a.inputValue === "" && (U.value = null, n("clear", !0));
    }, re = () => {
      I.value = !0, n("focus"), et().then(() => {
        var p;
        f.value.enabled && f.value.selectOnFocus && ((p = S.value) == null || p.select());
      });
    }, O = (p) => {
      p.preventDefault(), ft(p, C.value, !0), f.value.enabled && f.value.openMenu && !s.value.input && !a.isMenuOpen ? n("open") : f.value.enabled || n("toggle");
    }, W = () => {
      n("real-blur"), I.value = !1, (!a.isMenuOpen || s.value.enabled && s.value.input) && n("blur"), a.autoApply && f.value.enabled && U.value && !a.isMenuOpen && (n("set-input-date", U.value), n("select-date"), U.value = null);
    }, te = (p) => {
      ft(p, C.value, !0), n("clear");
    }, V = (p) => {
      if (!f.value.enabled) {
        if (p.code === "Tab")
          return;
        p.preventDefault();
      }
    };
    return t({
      focusInput: () => {
        var p;
        (p = S.value) == null || p.focus({ preventScroll: !0 });
      },
      setParsedDate: (p) => {
        U.value = p;
      }
    }), (p, J) => {
      var E;
      return $(), j("div", { onClick: O }, [
        p.$slots.trigger && !p.$slots["dp-input"] && !i(s).enabled ? se(p.$slots, "trigger", { key: 0 }) : X("", !0),
        !p.$slots.trigger && (!i(s).enabled || i(s).input) ? ($(), j("div", Ul, [
          p.$slots["dp-input"] && !p.$slots.trigger && (!i(s).enabled || i(s).enabled && i(s).input) ? se(p.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: y,
            onEnter: ie,
            onTab: oe,
            onClear: te,
            onBlur: W,
            onKeypress: V,
            onPaste: Y,
            openMenu: () => p.$emit("open"),
            closeMenu: () => p.$emit("close"),
            toggleMenu: () => p.$emit("toggle")
          }) : X("", !0),
          p.$slots["dp-input"] ? X("", !0) : ($(), j("input", {
            key: 1,
            id: p.uid ? `dp-input-${p.uid}` : void 0,
            ref_key: "inputRef",
            ref: S,
            "data-test": "dp-input",
            name: p.name,
            class: Me(L.value),
            inputmode: i(f).enabled ? "text" : "none",
            placeholder: p.placeholder,
            disabled: p.disabled,
            readonly: p.readonly,
            required: p.required,
            value: e.inputValue,
            autocomplete: p.autocomplete,
            "aria-label": (E = i(v)) == null ? void 0 : E.input,
            "aria-disabled": p.disabled || void 0,
            "aria-invalid": p.state === !1 ? !0 : void 0,
            onInput: y,
            onKeydown: [
              fe(ie, ["enter"]),
              fe(oe, ["tab"]),
              V
            ],
            onBlur: W,
            onFocus: re,
            onKeypress: V,
            onPaste: Y
          }, null, 42, Kl)),
          ce("div", {
            onClick: J[2] || (J[2] = (m) => n("toggle"))
          }, [
            p.$slots["input-icon"] && !p.hideInputIcon ? ($(), j("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: J[0] || (J[0] = (m) => n("toggle"))
            }, [
              se(p.$slots, "input-icon")
            ])) : X("", !0),
            !p.$slots["input-icon"] && !p.hideInputIcon && !p.$slots["dp-input"] ? ($(), we(i(Ot), {
              key: 1,
              class: "dp__input_icon dp__input_icons",
              onClick: J[1] || (J[1] = (m) => n("toggle"))
            })) : X("", !0)
          ]),
          p.$slots["clear-icon"] && e.inputValue && p.clearable && !p.disabled && !p.readonly ? ($(), j("span", jl, [
            se(p.$slots, "clear-icon", { clear: te })
          ])) : X("", !0),
          p.clearable && !p.$slots["clear-icon"] && e.inputValue && !p.disabled && !p.readonly ? ($(), we(i(yn), {
            key: 3,
            class: "dp__clear_icon dp__input_icons",
            "data-test": "clear-icon",
            onClick: J[3] || (J[3] = $e((m) => te(m), ["prevent"]))
          })) : X("", !0)
        ])) : X("", !0)
      ]);
    };
  }
}), Ql = ["title"], ql = ["disabled"], Xl = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...tt
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: t }) {
    const r = t, n = e, {
      defaultedActionRow: a,
      defaultedPreviewFormat: f,
      defaultedMultiCalendars: v,
      defaultedTextInput: s,
      defaultedInline: C,
      defaultedRange: B,
      defaultedMultiDates: h,
      getDefaultPattern: w
    } = Re(n), { isTimeValid: k, isMonthValid: _ } = gt(n), { buildMatrix: U } = pt(), S = ee(null), I = ee(null), b = ee(!1), L = ee({}), N = ee(null), q = ee(null);
    He(() => {
      n.arrowNavigation && U([Ye(S), Ye(I)], "actionRow"), F(), window.addEventListener("resize", F);
    }), na(() => {
      window.removeEventListener("resize", F);
    });
    const F = () => {
      b.value = !1, setTimeout(() => {
        var T, p;
        const V = (T = N.value) == null ? void 0 : T.getBoundingClientRect(), c = (p = q.value) == null ? void 0 : p.getBoundingClientRect();
        V && c && (L.value.maxWidth = `${c.width - V.width - 20}px`), b.value = !0;
      }, 0);
    }, Y = Q(() => B.value.enabled && !B.value.partialRange && n.internalModelValue ? n.internalModelValue.length === 2 : !0), K = Q(
      () => !k.value(n.internalModelValue) || !_.value(n.internalModelValue) || !Y.value
    ), y = () => {
      const V = f.value;
      return n.timePicker || n.monthPicker, V(Be(n.internalModelValue));
    }, ie = () => {
      const V = n.internalModelValue;
      return v.value.count > 0 ? `${oe(V[0])} - ${oe(V[1])}` : [oe(V[0]), oe(V[1])];
    }, oe = (V) => Pn(
      V,
      f.value,
      n.formatLocale,
      s.value.rangeSeparator,
      n.modelAuto,
      w()
    ), re = Q(() => !n.internalModelValue || !n.menuMount ? "" : typeof f.value == "string" ? Array.isArray(n.internalModelValue) ? n.internalModelValue.length === 2 && n.internalModelValue[1] ? ie() : h.value.enabled ? n.internalModelValue.map((V) => `${oe(V)}`) : n.modelAuto ? `${oe(n.internalModelValue[0])}` : `${oe(n.internalModelValue[0])} -` : oe(n.internalModelValue) : y()), O = () => h.value.enabled ? "; " : " - ", W = Q(
      () => Array.isArray(re.value) ? re.value.join(O()) : re.value
    ), te = () => {
      k.value(n.internalModelValue) && _.value(n.internalModelValue) && Y.value ? r("select-date") : r("invalid-select");
    };
    return (V, c) => ($(), j("div", {
      ref_key: "actionRowRef",
      ref: q,
      class: "dp__action_row"
    }, [
      V.$slots["action-row"] ? se(V.$slots, "action-row", Ie(Ne({ key: 0 }, {
        internalModelValue: V.internalModelValue,
        disabled: K.value,
        selectDate: () => V.$emit("select-date"),
        closePicker: () => V.$emit("close-picker")
      }))) : ($(), j(ke, { key: 1 }, [
        i(a).showPreview ? ($(), j("div", {
          key: 0,
          class: "dp__selection_preview",
          title: W.value,
          style: qe(L.value)
        }, [
          V.$slots["action-preview"] && b.value ? se(V.$slots, "action-preview", {
            key: 0,
            value: V.internalModelValue
          }) : X("", !0),
          !V.$slots["action-preview"] && b.value ? ($(), j(ke, { key: 1 }, [
            it(Ve(W.value), 1)
          ], 64)) : X("", !0)
        ], 12, Ql)) : X("", !0),
        ce("div", {
          ref_key: "actionBtnContainer",
          ref: N,
          class: "dp__action_buttons",
          "data-dp-element": "action-row"
        }, [
          V.$slots["action-buttons"] ? se(V.$slots, "action-buttons", {
            key: 0,
            value: V.internalModelValue
          }) : X("", !0),
          V.$slots["action-buttons"] ? X("", !0) : ($(), j(ke, { key: 1 }, [
            !i(C).enabled && i(a).showCancel ? ($(), j("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: S,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: c[0] || (c[0] = (T) => V.$emit("close-picker")),
              onKeydown: [
                c[1] || (c[1] = fe((T) => V.$emit("close-picker"), ["enter"])),
                c[2] || (c[2] = fe((T) => V.$emit("close-picker"), ["space"]))
              ]
            }, Ve(V.cancelText), 545)) : X("", !0),
            i(a).showNow ? ($(), j("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: c[3] || (c[3] = (T) => V.$emit("select-now")),
              onKeydown: [
                c[4] || (c[4] = fe((T) => V.$emit("select-now"), ["enter"])),
                c[5] || (c[5] = fe((T) => V.$emit("select-now"), ["space"]))
              ]
            }, Ve(V.nowButtonLabel), 33)) : X("", !0),
            i(a).showSelect ? ($(), j("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: I,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: K.value,
              "data-test": "select-button",
              onKeydown: [
                fe(te, ["enter"]),
                fe(te, ["space"])
              ],
              onClick: te
            }, Ve(V.selectText), 41, ql)) : X("", !0)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
}), Jl = ["onKeydown"], Zl = { class: "dp__selection_grid_header" }, xl = ["aria-selected", "aria-disabled", "data-test", "onClick", "onKeydown", "onMouseover"], er = ["aria-label"], jt = /* @__PURE__ */ Ee({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    ariaLabels: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: t, emit: r }) {
    const { setSelectionGrid: n, buildMultiLevelMatrix: a, setMonthPicker: f } = pt(), v = r, s = e, { defaultedAriaLabels: C, defaultedTextInput: B, defaultedConfig: h } = Re(
      s
    ), { hideNavigationButtons: w } = oa(), k = ee(!1), _ = ee(null), U = ee(null), S = ee([]), I = ee(), b = ee(null), L = ee(0), N = ee(null);
    Vn(() => {
      _.value = null;
    }), He(() => {
      et().then(() => re()), s.noOverlayFocus || F(), q(!0);
    }), na(() => q(!1));
    const q = (E) => {
      var m;
      s.arrowNavigation && ((m = s.headerRefs) != null && m.length ? f(E) : n(E));
    }, F = () => {
      var m;
      const E = Ye(U);
      E && (B.value.enabled || (_.value ? (m = _.value) == null || m.focus({ preventScroll: !0 }) : E.focus({ preventScroll: !0 })), k.value = E.clientHeight < E.scrollHeight);
    }, Y = Q(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !s.useRelative,
        "dp--overlay-relative": s.useRelative
      })
    ), K = Q(
      () => s.useRelative ? { height: `${s.height}px`, width: "260px" } : void 0
    ), y = Q(() => ({
      dp__overlay_col: !0
    })), ie = Q(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: k.value,
        dp__button_bottom: s.isLast
      })
    ), oe = Q(() => {
      var E, m;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((E = s.items) == null ? void 0 : E.length) <= 6,
        dp__container_block: ((m = s.items) == null ? void 0 : m.length) > 6
      };
    });
    mt(
      () => s.items,
      () => re(!1),
      { deep: !0 }
    );
    const re = (E = !0) => {
      et().then(() => {
        const m = Ye(_), H = Ye(U), ne = Ye(b), u = Ye(N), M = ne ? ne.getBoundingClientRect().height : 0;
        H && (H.getBoundingClientRect().height ? L.value = H.getBoundingClientRect().height - M : L.value = h.value.modeHeight - M), m && u && E && (u.scrollTop = m.offsetTop - u.offsetTop - (L.value / 2 - m.getBoundingClientRect().height) - M);
      });
    }, O = (E) => {
      E.disabled || v("selected", E.value);
    }, W = () => {
      v("toggle"), v("reset-flow");
    }, te = () => {
      s.escClose && W();
    }, V = (E, m, H, ne) => {
      E && ((m.active || m.value === s.focusValue) && (_.value = E), s.arrowNavigation && (Array.isArray(S.value[H]) ? S.value[H][ne] = E : S.value[H] = [E], c()));
    }, c = () => {
      var m, H;
      const E = (m = s.headerRefs) != null && m.length ? [s.headerRefs].concat(S.value) : S.value.concat([s.skipButtonRef ? [] : [b.value]]);
      a(Be(E), (H = s.headerRefs) != null && H.length ? "monthPicker" : "selectionGrid");
    }, T = (E) => {
      s.arrowNavigation || ft(E, h.value, !0);
    }, p = (E) => {
      I.value = E, v("hover-value", E);
    }, J = () => {
      if (W(), !s.isLast) {
        const E = cl(s.menuWrapRef ?? null, "action-row");
        if (E) {
          const m = wn(E);
          m == null || m.focus();
        }
      }
    };
    return t({ focusGrid: F }), (E, m) => {
      var H;
      return $(), j("div", {
        ref_key: "gridWrapRef",
        ref: U,
        class: Me(Y.value),
        style: qe(K.value),
        role: "dialog",
        tabindex: "0",
        onKeydown: [
          fe($e(te, ["prevent"]), ["esc"]),
          m[0] || (m[0] = fe($e((ne) => T(ne), ["prevent"]), ["left"])),
          m[1] || (m[1] = fe($e((ne) => T(ne), ["prevent"]), ["up"])),
          m[2] || (m[2] = fe($e((ne) => T(ne), ["prevent"]), ["down"])),
          m[3] || (m[3] = fe($e((ne) => T(ne), ["prevent"]), ["right"]))
        ]
      }, [
        ce("div", {
          ref_key: "containerRef",
          ref: N,
          class: Me(oe.value),
          role: "grid",
          style: qe({ "--dp-overlay-height": `${L.value}px` })
        }, [
          ce("div", Zl, [
            se(E.$slots, "header")
          ]),
          E.$slots.overlay ? se(E.$slots, "overlay", { key: 0 }) : ($(!0), j(ke, { key: 1 }, Pe(E.items, (ne, u) => ($(), j("div", {
            key: u,
            class: Me(["dp__overlay_row", { dp__flex_row: E.items.length >= 3 }]),
            role: "row"
          }, [
            ($(!0), j(ke, null, Pe(ne, (M, R) => ($(), j("div", {
              key: M.value,
              ref_for: !0,
              ref: (de) => V(de, M, u, R),
              role: "gridcell",
              class: Me(y.value),
              "aria-selected": M.active || void 0,
              "aria-disabled": M.disabled || void 0,
              tabindex: "0",
              "data-test": M.text,
              onClick: (de) => O(M),
              onKeydown: [
                fe($e((de) => O(M), ["prevent"]), ["enter"]),
                fe($e((de) => O(M), ["prevent"]), ["space"])
              ],
              onMouseover: (de) => p(M.value)
            }, [
              ce("div", {
                class: Me(M.className)
              }, [
                E.$slots.item ? se(E.$slots, "item", {
                  key: 0,
                  item: M
                }) : X("", !0),
                E.$slots.item ? X("", !0) : ($(), j(ke, { key: 1 }, [
                  it(Ve(M.text), 1)
                ], 64))
              ], 2)
            ], 42, xl))), 128))
          ], 2))), 128))
        ], 6),
        E.$slots["button-icon"] ? xt(($(), j("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: b,
          type: "button",
          "aria-label": (H = i(C)) == null ? void 0 : H.toggleOverlay,
          class: Me(ie.value),
          tabindex: "0",
          onClick: W,
          onKeydown: [
            fe(W, ["enter"]),
            fe(J, ["tab"])
          ]
        }, [
          se(E.$slots, "button-icon")
        ], 42, er)), [
          [ea, !i(w)(E.hideNavigation, E.type)]
        ]) : X("", !0)
      ], 46, Jl);
    };
  }
}), ua = /* @__PURE__ */ Ee({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean },
    collapse: { type: Boolean }
  },
  setup(e) {
    const t = e, r = Q(
      () => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]
    ), n = Q(() => ({
      dp__instance_calendar: t.multiCalendars > 0
    }));
    return (a, f) => ($(), j("div", {
      class: Me({
        dp__menu_inner: !a.stretch,
        "dp--menu--inner-stretched": a.stretch,
        dp__flex_display: a.multiCalendars > 0,
        "dp--flex-display-collapsed": a.collapse
      })
    }, [
      ($(!0), j(ke, null, Pe(r.value, (v, s) => ($(), j("div", {
        key: v,
        class: Me(n.value)
      }, [
        se(a.$slots, "default", {
          instance: v,
          index: s
        })
      ], 2))), 128))
    ], 2));
  }
}), tr = ["aria-label", "aria-disabled"], Ft = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: t }) {
    const r = t, n = ee(null);
    return He(() => r("set-ref", n)), (a, f) => ($(), j("button", {
      ref_key: "elRef",
      ref: n,
      type: "button",
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": a.ariaLabel,
      "aria-disabled": a.disabled || void 0,
      onClick: f[0] || (f[0] = (v) => a.$emit("activate")),
      onKeydown: [
        f[1] || (f[1] = fe($e((v) => a.$emit("activate"), ["prevent"]), ["enter"])),
        f[2] || (f[2] = fe($e((v) => a.$emit("activate"), ["prevent"]), ["space"]))
      ]
    }, [
      ce("span", {
        class: Me(["dp__inner_nav", { dp__inner_nav_disabled: a.disabled }])
      }, [
        se(a.$slots, "default")
      ], 2)
    ], 40, tr));
  }
}), ar = { class: "dp--year-mode-picker" }, nr = ["aria-label", "data-test"], _n = /* @__PURE__ */ Ee({
  __name: "YearModePicker",
  props: {
    ...tt,
    showYearPicker: { type: Boolean, default: !1 },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => !1 }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e, { emit: t }) {
    const r = t, n = e, { showRightIcon: a, showLeftIcon: f } = oa(), { defaultedConfig: v, defaultedMultiCalendars: s, defaultedAriaLabels: C, defaultedTransitions: B } = Re(n), { showTransition: h, transitionName: w } = Ut(B), k = (S = !1, I) => {
      r("toggle-year-picker", { flow: S, show: I });
    }, _ = (S) => {
      r("year-select", S);
    }, U = (S = !1) => {
      r("handle-year", S);
    };
    return (S, I) => {
      var b, L, N;
      return $(), j("div", ar, [
        i(f)(i(s), e.instance) ? ($(), we(Ft, {
          key: 0,
          ref: "mpPrevIconRef",
          "aria-label": (b = i(C)) == null ? void 0 : b.prevYear,
          disabled: e.isDisabled(!1),
          onActivate: I[0] || (I[0] = (q) => U(!1))
        }, {
          default: ye(() => [
            S.$slots["arrow-left"] ? se(S.$slots, "arrow-left", { key: 0 }) : X("", !0),
            S.$slots["arrow-left"] ? X("", !0) : ($(), we(i(Ea), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : X("", !0),
        ce("button", {
          ref: "mpYearButtonRef",
          class: "dp__btn dp--year-select",
          type: "button",
          "aria-label": (L = i(C)) == null ? void 0 : L.openYearsOverlay,
          "data-test": `year-mode-btn-${e.instance}`,
          onClick: I[1] || (I[1] = () => k(!1)),
          onKeydown: I[2] || (I[2] = fe(() => k(!1), ["enter"]))
        }, [
          S.$slots.year ? se(S.$slots, "year", {
            key: 0,
            year: e.year
          }) : X("", !0),
          S.$slots.year ? X("", !0) : ($(), j(ke, { key: 1 }, [
            it(Ve(e.year), 1)
          ], 64))
        ], 40, nr),
        i(a)(i(s), e.instance) ? ($(), we(Ft, {
          key: 1,
          ref: "mpNextIconRef",
          "aria-label": (N = i(C)) == null ? void 0 : N.nextYear,
          disabled: e.isDisabled(!0),
          onActivate: I[3] || (I[3] = (q) => U(!0))
        }, {
          default: ye(() => [
            S.$slots["arrow-right"] ? se(S.$slots, "arrow-right", { key: 0 }) : X("", !0),
            S.$slots["arrow-right"] ? X("", !0) : ($(), we(i(Fa), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : X("", !0),
        Xe(_t, {
          name: i(w)(e.showYearPicker),
          css: i(h)
        }, {
          default: ye(() => [
            e.showYearPicker ? ($(), we(jt, {
              key: 0,
              items: e.items,
              "text-input": S.textInput,
              "esc-close": S.escClose,
              config: S.config,
              "is-last": S.autoApply && !i(v).keepActionRow,
              "hide-navigation": S.hideNavigation,
              "aria-labels": S.ariaLabels,
              type: "year",
              onToggle: k,
              onSelected: I[4] || (I[4] = (q) => _(q))
            }, We({
              "button-icon": ye(() => [
                S.$slots["calendar-icon"] ? se(S.$slots, "calendar-icon", { key: 0 }) : X("", !0),
                S.$slots["calendar-icon"] ? X("", !0) : ($(), we(i(Ot), { key: 1 }))
              ]),
              _: 2
            }, [
              S.$slots["year-overlay-value"] ? {
                name: "item",
                fn: ye(({ item: q }) => [
                  se(S.$slots, "year-overlay-value", {
                    text: q.text,
                    value: q.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels"])) : X("", !0)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), ja = (e, t, r) => {
  if (t.value && Array.isArray(t.value))
    if (t.value.some((n) => be(e, n))) {
      const n = t.value.filter((a) => !be(a, e));
      t.value = n.length ? n : null;
    } else
      (r && +r > t.value.length || !r) && t.value.push(e);
  else
    t.value = [e];
}, Ga = (e, t, r) => {
  let n = e.value ? e.value.slice() : [];
  return n.length === 2 && n[1] !== null && (n = []), n.length ? Ce(t, n[0]) ? (n.unshift(t), r("range-start", n[0]), r("range-start", n[1])) : (n[1] = t, r("range-end", t)) : (n = [t], r("range-start", t)), n;
}, ia = (e, t, r, n) => {
  e && (e[0] && e[1] && r && t("auto-apply"), e[0] && !e[1] && n && r && t("auto-apply"));
}, On = (e) => {
  Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map((t) => ot(z(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = ot(z(e.value), e.timezone));
}, Bn = (e, t, r, n) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && n.value.partialRange) ? n.value.fixedStart && (Oe(e, t.value[0]) || be(e, t.value[0])) ? [t.value[0], e] : n.value.fixedEnd && (Ce(e, t.value[1]) || be(e, t.value[1])) ? [e, t.value[1]] : (r("invalid-fixed-range", e), t.value) : [], Yn = ({
  multiCalendars: e,
  highlight: t,
  propDates: r,
  calendars: n,
  modelValue: a,
  props: f,
  filters: v,
  year: s,
  month: C,
  emit: B
}) => {
  const h = Q(() => Ha(f.yearRange, f.locale, f.reverseYears)), w = ee([!1]), k = Q(() => (Y, K) => {
    const y = Ae(Ze(/* @__PURE__ */ new Date()), {
      month: C.value(Y),
      year: s.value(Y)
    });
    return Sn(
      y,
      r.value.maxDate,
      r.value.minDate,
      f.preventMinMaxNavigation,
      K
    );
  }), _ = () => {
    for (let Y = 0; Y < e.value.count; Y++)
      if (Y === 0)
        n.value[Y] = n.value[0];
      else {
        const K = Ae(z(), n.value[Y - 1]);
        n.value[Y] = { month: he(K), year: pe(mn(K, 1)) };
      }
  }, U = (Y) => {
    if (!Y)
      return _();
    const K = Ae(z(), n.value[Y]);
    return n.value[0].year = pe(pn(K, e.value.count - 1)), _();
  }, S = (Y) => f.focusStartDate ? Y[0] : Y[1] ? Y[1] : Y[0], I = () => {
    if (a.value) {
      const Y = Array.isArray(a.value) ? S(a.value) : a.value;
      n.value[0] = { month: he(Y), year: pe(Y) };
    }
  };
  He(() => {
    I(), e.value.count && _();
  });
  const b = (Y, K) => {
    n.value[K].year = Y, B("update-month-year", { instance: K, year: Y, month: n.value[K].month }), e.value.count && !e.value.solo && U(K);
  }, L = Q(() => (Y) => Rt(h.value, (K) => {
    var re;
    const y = s.value(Y) === K.value, ie = Ht(
      K.value,
      Ct(r.value.minDate),
      Ct(r.value.maxDate)
    ) || ((re = v.value.years) == null ? void 0 : re.includes(s.value(Y))), oe = Ka(t.value, K.value);
    return { active: y, disabled: ie, highlighted: oe };
  })), N = (Y, K) => {
    b(Y, K), F(K);
  }, q = (Y, K = !1) => {
    if (!k.value(Y, K)) {
      const y = K ? s.value(Y) + 1 : s.value(Y) - 1;
      b(y, Y);
    }
  }, F = (Y, K = !1, y) => {
    K || B("reset-flow"), y !== void 0 ? w.value[Y] = y : w.value[Y] = !w.value[Y], w.value || B("overlay-closed");
  };
  return {
    isDisabled: k,
    groupedYears: L,
    showYearPicker: w,
    selectYear: b,
    toggleYearPicker: F,
    handleYearSelect: N,
    handleYear: q
  };
}, lr = (e, t) => {
  const {
    defaultedMultiCalendars: r,
    defaultedAriaLabels: n,
    defaultedTransitions: a,
    defaultedConfig: f,
    defaultedRange: v,
    defaultedHighlight: s,
    propDates: C,
    defaultedTz: B,
    defaultedFilters: h,
    defaultedMultiDates: w
  } = Re(e), { modelValue: k, year: _, month: U, calendars: S } = Kt(e, t), I = Q(() => bn(e.formatLocale, e.locale, e.monthNameFormat)), b = ee(null), { checkMinMaxRange: L } = gt(e), {
    selectYear: N,
    groupedYears: q,
    showYearPicker: F,
    toggleYearPicker: Y,
    handleYearSelect: K,
    handleYear: y,
    isDisabled: ie
  } = Yn({
    modelValue: k,
    multiCalendars: r,
    highlight: s,
    calendars: S,
    year: _,
    propDates: C,
    month: U,
    filters: h,
    props: e,
    emit: t
  });
  He(() => {
    e.startDate && (k.value && e.focusStartDate || !k.value) && N(pe(z(e.startDate)), 0);
  });
  const oe = (M) => M ? { month: he(M), year: pe(M) } : { month: null, year: null }, re = () => k.value ? Array.isArray(k.value) ? k.value.map((M) => oe(M)) : oe(k.value) : oe(), O = (M, R) => {
    const de = S.value[M], d = re();
    return Array.isArray(d) ? d.some((le) => le.year === (de == null ? void 0 : de.year) && le.month === R) : (de == null ? void 0 : de.year) === d.year && R === d.month;
  }, W = (M, R, de) => {
    var le, l;
    const d = re();
    return Array.isArray(d) ? _.value(R) === ((le = d[de]) == null ? void 0 : le.year) && M === ((l = d[de]) == null ? void 0 : l.month) : !1;
  }, te = (M, R) => {
    if (v.value.enabled) {
      const de = re();
      if (Array.isArray(k.value) && Array.isArray(de)) {
        const d = W(M, R, 0) || W(M, R, 1), le = ut(Ze(z()), M, _.value(R));
        return ra(k.value, b.value, le) && !d;
      }
      return !1;
    }
    return !1;
  }, V = Q(() => (M) => Rt(I.value, (R) => {
    var P;
    const de = O(M, R.value), d = Ht(
      R.value,
      Dn(_.value(M), C.value.minDate),
      $n(_.value(M), C.value.maxDate)
    ) || bl(C.value.disabledDates, _.value(M)).includes(R.value) || ((P = h.value.months) == null ? void 0 : P.includes(R.value)), le = te(R.value, M), l = Rn(s.value, R.value, _.value(M));
    return { active: de, disabled: d, isBetween: le, highlighted: l };
  })), c = (M, R) => ut(Ze(z()), M, _.value(R)), T = (M, R) => {
    const de = k.value ? k.value : Ze(/* @__PURE__ */ new Date());
    k.value = ut(de, M, _.value(R)), t("auto-apply"), t("update-flow-step");
  }, p = (M, R) => {
    const de = c(M, R);
    v.value.fixedEnd || v.value.fixedStart ? k.value = Bn(de, k, t, v) : k.value ? L(de, k.value) && (k.value = Ga(k, c(M, R), t)) : k.value = [c(M, R)], et().then(() => {
      ia(k.value, t, e.autoApply, e.modelAuto);
    });
  }, J = (M, R) => {
    ja(c(M, R), k, w.value.limit), t("auto-apply", !0);
  }, E = (M, R) => (S.value[R].month = M, H(R, S.value[R].year, M), w.value.enabled ? J(M, R) : v.value.enabled ? p(M, R) : T(M, R)), m = (M, R) => {
    N(M, R), H(R, M, null);
  }, H = (M, R, de) => {
    let d = de;
    if (!d && d !== 0) {
      const le = re();
      d = Array.isArray(le) ? le[M].month : le.month;
    }
    t("update-month-year", { instance: M, year: R, month: d });
  };
  return {
    groupedMonths: V,
    groupedYears: q,
    year: _,
    isDisabled: ie,
    defaultedMultiCalendars: r,
    defaultedAriaLabels: n,
    defaultedTransitions: a,
    defaultedConfig: f,
    showYearPicker: F,
    modelValue: k,
    presetDate: (M, R) => {
      On({
        value: M,
        modelValue: k,
        range: v.value.enabled,
        timezone: R ? void 0 : B.value.timezone
      }), t("auto-apply");
    },
    setHoverDate: (M, R) => {
      b.value = c(M, R);
    },
    selectMonth: E,
    selectYear: m,
    toggleYearPicker: Y,
    handleYearSelect: K,
    handleYear: y,
    getModelMonthYear: re
  };
}, rr = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...tt
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year",
    "update-flow-step",
    "mount",
    "invalid-fixed-range"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = Dt(), f = Ge(a, "yearMode"), v = e;
    He(() => {
      v.shadow || n("mount", null);
    });
    const {
      groupedMonths: s,
      groupedYears: C,
      year: B,
      isDisabled: h,
      defaultedMultiCalendars: w,
      defaultedConfig: k,
      showYearPicker: _,
      modelValue: U,
      presetDate: S,
      setHoverDate: I,
      selectMonth: b,
      selectYear: L,
      toggleYearPicker: N,
      handleYearSelect: q,
      handleYear: F,
      getModelMonthYear: Y
    } = lr(v, n);
    return t({ getSidebarProps: () => ({
      modelValue: U,
      year: B,
      getModelMonthYear: Y,
      selectMonth: b,
      selectYear: L,
      handleYear: F
    }), presetDate: S, toggleYearPicker: (y) => N(0, y) }), (y, ie) => ($(), we(ua, {
      "multi-calendars": i(w).count,
      collapse: y.collapse,
      stretch: ""
    }, {
      default: ye(({ instance: oe }) => [
        y.$slots["top-extra"] ? se(y.$slots, "top-extra", {
          key: 0,
          value: y.internalModelValue
        }) : X("", !0),
        y.$slots["month-year"] ? se(y.$slots, "month-year", Ie(Ne({ key: 1 }, {
          year: i(B),
          months: i(s)(oe),
          years: i(C)(oe),
          selectMonth: i(b),
          selectYear: i(L),
          instance: oe
        }))) : ($(), we(jt, {
          key: 2,
          items: i(s)(oe),
          "arrow-navigation": y.arrowNavigation,
          "is-last": y.autoApply && !i(k).keepActionRow,
          "esc-close": y.escClose,
          height: i(k).modeHeight,
          config: y.config,
          "no-overlay-focus": !!(y.noOverlayFocus || y.textInput),
          "use-relative": "",
          type: "month",
          onSelected: (re) => i(b)(re, oe),
          onHoverValue: (re) => i(I)(re, oe)
        }, We({
          header: ye(() => [
            Xe(_n, Ne(y.$props, {
              items: i(C)(oe),
              instance: oe,
              "show-year-picker": i(_)[oe],
              year: i(B)(oe),
              "is-disabled": (re) => i(h)(oe, re),
              onHandleYear: (re) => i(F)(oe, re),
              onYearSelect: (re) => i(q)(re, oe),
              onToggleYearPicker: (re) => i(N)(oe, re == null ? void 0 : re.flow, re == null ? void 0 : re.show)
            }), We({ _: 2 }, [
              Pe(i(f), (re, O) => ({
                name: re,
                fn: ye((W) => [
                  se(y.$slots, re, Ie(ze(W)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, [
          y.$slots["month-overlay-value"] ? {
            name: "item",
            fn: ye(({ item: re }) => [
              se(y.$slots, "month-overlay-value", {
                text: re.text,
                value: re.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse"]));
  }
}), or = (e, t) => {
  const { modelValue: r } = Kt(e, t), n = ee(null), { defaultedHighlight: a, defaultedMultiDates: f, defaultedFilters: v, defaultedRange: s, propDates: C } = Re(e), B = ee();
  He(() => {
    e.startDate && (r.value && e.focusStartDate || !r.value) && (B.value = pe(z(e.startDate)));
  });
  const h = (I) => Array.isArray(r.value) ? r.value.some((b) => pe(b) === I) : r.value ? pe(r.value) === I : !1, w = (I) => s.value.enabled && Array.isArray(r.value) ? ra(r.value, n.value, _(I)) : !1, k = Q(() => Rt(Ha(e.yearRange, e.locale, e.reverseYears), (I) => {
    const b = h(I.value), L = Ht(
      I.value,
      Ct(C.value.minDate),
      Ct(C.value.maxDate)
    ) || v.value.years.includes(I.value), N = w(I.value) && !b, q = Ka(a.value, I.value);
    return { active: b, disabled: L, isBetween: N, highlighted: q };
  })), _ = (I) => nt(Ze(/* @__PURE__ */ new Date()), I);
  return {
    groupedYears: k,
    modelValue: r,
    focusYear: B,
    setHoverValue: (I) => {
      n.value = nt(Ze(/* @__PURE__ */ new Date()), I);
    },
    selectYear: (I) => {
      var b;
      if (t("update-month-year", { instance: 0, year: I }), f.value.enabled)
        return r.value ? Array.isArray(r.value) && (((b = r.value) == null ? void 0 : b.map((N) => pe(N))).includes(I) ? r.value = r.value.filter((N) => pe(N) !== I) : r.value.push(nt(Qe(z()), I))) : r.value = [nt(Qe(z()), I)], t("auto-apply", !0);
      s.value.enabled ? (r.value = Ga(r, _(I), t), et().then(() => {
        ia(r.value, t, e.autoApply, e.modelAuto);
      })) : (r.value = _(I), t("auto-apply"));
    }
  };
}, sr = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...tt
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, { groupedYears: f, modelValue: v, focusYear: s, selectYear: C, setHoverValue: B } = or(a, n), { defaultedConfig: h } = Re(a);
    return t({ getSidebarProps: () => ({
      modelValue: v,
      selectYear: C
    }) }), (k, _) => ($(), j("div", null, [
      k.$slots["top-extra"] ? se(k.$slots, "top-extra", {
        key: 0,
        value: k.internalModelValue
      }) : X("", !0),
      k.$slots["month-year"] ? se(k.$slots, "month-year", Ie(Ne({ key: 1 }, {
        years: i(f),
        selectYear: i(C)
      }))) : ($(), we(jt, {
        key: 2,
        items: i(f),
        "is-last": k.autoApply && !i(h).keepActionRow,
        height: i(h).modeHeight,
        config: k.config,
        "no-overlay-focus": !!(k.noOverlayFocus || k.textInput),
        "focus-value": i(s),
        type: "year",
        "use-relative": "",
        onSelected: i(C),
        onHoverValue: i(B)
      }, We({ _: 2 }, [
        k.$slots["year-overlay-value"] ? {
          name: "item",
          fn: ye(({ item: U }) => [
            se(k.$slots, "year-overlay-value", {
              text: U.text,
              value: U.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
}), ur = {
  key: 0,
  class: "dp__time_input"
}, ir = ["data-test", "aria-label", "onKeydown", "onClick"], dr = /* @__PURE__ */ ce("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), cr = /* @__PURE__ */ ce("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), fr = ["aria-label", "disabled", "data-test", "onKeydown", "onClick"], vr = ["data-test", "aria-label", "onKeydown", "onClick"], mr = /* @__PURE__ */ ce("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), pr = /* @__PURE__ */ ce("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), gr = { key: 0 }, yr = ["aria-label", "onKeydown"], hr = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => !1 },
    ...tt
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, { setTimePickerElements: f, setTimePickerBackRef: v } = pt(), { defaultedAriaLabels: s, defaultedTransitions: C, defaultedFilters: B, defaultedConfig: h, defaultedRange: w } = Re(a), { transitionName: k, showTransition: _ } = Ut(C), U = zt({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), S = ee("AM"), I = ee(null), b = ee([]);
    He(() => {
      n("mounted");
    });
    const L = (l) => Ae(/* @__PURE__ */ new Date(), {
      hours: l.hours,
      minutes: l.minutes,
      seconds: a.enableSeconds ? l.seconds : 0,
      milliseconds: 0
    }), N = Q(
      () => (l) => V(l, a[l]) || F(l, a[l])
    ), q = Q(() => ({ hours: a.hours, minutes: a.minutes, seconds: a.seconds })), F = (l, P) => w.value.enabled && !w.value.disableTimeRangeValidation ? !a.validateTime(l, P) : !1, Y = (l, P) => {
      if (w.value.enabled && !w.value.disableTimeRangeValidation) {
        const x = P ? +a[`${l}Increment`] : -+a[`${l}Increment`], Z = a[l] + x;
        return !a.validateTime(l, Z);
      }
      return !1;
    }, K = Q(() => (l) => !E(+a[l] + +a[`${l}Increment`], l) || Y(l, !0)), y = Q(() => (l) => !E(+a[l] - +a[`${l}Increment`], l) || Y(l, !1)), ie = (l, P) => gn(Ae(z(), l), P), oe = (l, P) => qn(Ae(z(), l), P), re = Q(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !a.timePickerInline,
        dp__time_col_reg_block: !a.enableSeconds && a.is24 && !a.timePickerInline,
        dp__time_col_reg_inline: !a.enableSeconds && a.is24 && a.timePickerInline,
        dp__time_col_reg_with_button: !a.enableSeconds && !a.is24,
        dp__time_col_sec: a.enableSeconds && a.is24,
        dp__time_col_sec_with_button: a.enableSeconds && !a.is24
      })
    ), O = Q(() => {
      const l = [{ type: "hours" }];
      return a.enableMinutes && l.push({ type: "", separator: !0 }, {
        type: "minutes"
      }), a.enableSeconds && l.push({ type: "", separator: !0 }, {
        type: "seconds"
      }), l;
    }), W = Q(() => O.value.filter((l) => !l.separator)), te = Q(() => (l) => {
      if (l === "hours") {
        const P = M(+a.hours);
        return { text: P < 10 ? `0${P}` : `${P}`, value: P };
      }
      return { text: a[l] < 10 ? `0${a[l]}` : `${a[l]}`, value: a[l] };
    }), V = (l, P) => {
      var Z;
      if (!a.disabledTimesConfig)
        return !1;
      const x = a.disabledTimesConfig(a.order, l === "hours" ? P : void 0);
      return x[l] ? !!((Z = x[l]) != null && Z.includes(P)) : !0;
    }, c = (l, P) => P !== "hours" || S.value === "AM" ? l : l + 12, T = (l) => {
      const P = a.is24 ? 24 : 12, x = l === "hours" ? P : 60, Z = +a[`${l}GridIncrement`], ae = l === "hours" && !a.is24 ? Z : 0, g = [];
      for (let A = ae; A < x; A += Z)
        g.push({ value: a.is24 ? A : c(A, l), text: A < 10 ? `0${A}` : `${A}` });
      return l === "hours" && !a.is24 && g.push({ value: 0, text: "12" }), Rt(g, (A) => ({ active: !1, disabled: B.value.times[l].includes(A.value) || !E(A.value, l) || V(l, A.value) || F(l, A.value) }));
    }, p = (l) => l >= 0 ? l : 59, J = (l) => l >= 0 ? l : 23, E = (l, P) => {
      const x = a.minTime ? L(wa(a.minTime)) : null, Z = a.maxTime ? L(wa(a.maxTime)) : null, ae = L(
        wa(
          q.value,
          P,
          P === "minutes" || P === "seconds" ? p(l) : J(l)
        )
      );
      return x && Z ? (Wt(ae, Z) || Tt(ae, Z)) && (St(ae, x) || Tt(ae, x)) : x ? St(ae, x) || Tt(ae, x) : Z ? Wt(ae, Z) || Tt(ae, Z) : !0;
    }, m = (l) => a[`no${l[0].toUpperCase() + l.slice(1)}Overlay`], H = (l) => {
      m(l) || (U[l] = !U[l], U[l] || n("overlay-closed"));
    }, ne = (l) => l === "hours" ? xe : l === "minutes" ? rt : Pt, u = (l, P = !0) => {
      const x = P ? ie : oe, Z = P ? +a[`${l}Increment`] : -+a[`${l}Increment`];
      E(+a[l] + Z, l) && n(
        `update:${l}`,
        ne(l)(x({ [l]: +a[l] }, { [l]: +a[`${l}Increment`] }))
      );
    }, M = (l) => a.is24 ? l : (l >= 12 ? S.value = "PM" : S.value = "AM", ol(l)), R = () => {
      S.value === "PM" ? (S.value = "AM", n("update:hours", a.hours - 12)) : (S.value = "PM", n("update:hours", a.hours + 12)), n("am-pm-change", S.value);
    }, de = (l) => {
      U[l] = !0;
    }, d = (l, P, x) => {
      if (l && a.arrowNavigation) {
        Array.isArray(b.value[P]) ? b.value[P][x] = l : b.value[P] = [l];
        const Z = b.value.reduce(
          (ae, g) => g.map((A, ge) => [...ae[ge] || [], g[ge]]),
          []
        );
        v(a.closeTimePickerBtn), I.value && (Z[1] = Z[1].concat(I.value)), f(Z, a.order);
      }
    }, le = (l, P) => (H(l), n(`update:${l}`, P));
    return t({ openChildCmp: de }), (l, P) => {
      var x;
      return l.disabled ? X("", !0) : ($(), j("div", ur, [
        ($(!0), j(ke, null, Pe(O.value, (Z, ae) => {
          var g, A, ge;
          return $(), j("div", {
            key: ae,
            class: Me(re.value)
          }, [
            Z.separator ? ($(), j(ke, { key: 0 }, [
              it(" : ")
            ], 64)) : ($(), j(ke, { key: 1 }, [
              ce("button", {
                ref_for: !0,
                ref: (me) => d(me, ae, 0),
                type: "button",
                class: Me({
                  dp__btn: !0,
                  dp__inc_dec_button: !l.timePickerInline,
                  dp__inc_dec_button_inline: l.timePickerInline,
                  dp__tp_inline_btn_top: l.timePickerInline,
                  dp__inc_dec_button_disabled: K.value(Z.type)
                }),
                "data-test": `${Z.type}-time-inc-btn-${a.order}`,
                "aria-label": (g = i(s)) == null ? void 0 : g.incrementValue(Z.type),
                tabindex: "0",
                onKeydown: [
                  fe($e((me) => u(Z.type), ["prevent"]), ["enter"]),
                  fe($e((me) => u(Z.type), ["prevent"]), ["space"])
                ],
                onClick: (me) => u(Z.type)
              }, [
                a.timePickerInline ? ($(), j(ke, { key: 1 }, [
                  dr,
                  cr
                ], 64)) : ($(), j(ke, { key: 0 }, [
                  l.$slots["arrow-up"] ? se(l.$slots, "arrow-up", { key: 0 }) : X("", !0),
                  l.$slots["arrow-up"] ? X("", !0) : ($(), we(i(Va), { key: 1 }))
                ], 64))
              ], 42, ir),
              ce("button", {
                ref_for: !0,
                ref: (me) => d(me, ae, 1),
                type: "button",
                "aria-label": (A = i(s)) == null ? void 0 : A.openTpOverlay(Z.type),
                class: Me({
                  dp__time_display: !0,
                  dp__time_display_block: !l.timePickerInline,
                  dp__time_display_inline: l.timePickerInline,
                  "dp--time-invalid": N.value(Z.type),
                  "dp--time-overlay-btn": !N.value(Z.type)
                }),
                disabled: m(Z.type),
                tabindex: "0",
                "data-test": `${Z.type}-toggle-overlay-btn-${a.order}`,
                onKeydown: [
                  fe($e((me) => H(Z.type), ["prevent"]), ["enter"]),
                  fe($e((me) => H(Z.type), ["prevent"]), ["space"])
                ],
                onClick: (me) => H(Z.type)
              }, [
                l.$slots[Z.type] ? se(l.$slots, Z.type, {
                  key: 0,
                  text: te.value(Z.type).text,
                  value: te.value(Z.type).value
                }) : X("", !0),
                l.$slots[Z.type] ? X("", !0) : ($(), j(ke, { key: 1 }, [
                  it(Ve(te.value(Z.type).text), 1)
                ], 64))
              ], 42, fr),
              ce("button", {
                ref_for: !0,
                ref: (me) => d(me, ae, 2),
                type: "button",
                class: Me({
                  dp__btn: !0,
                  dp__inc_dec_button: !l.timePickerInline,
                  dp__inc_dec_button_inline: l.timePickerInline,
                  dp__tp_inline_btn_bottom: l.timePickerInline,
                  dp__inc_dec_button_disabled: y.value(Z.type)
                }),
                "data-test": `${Z.type}-time-dec-btn-${a.order}`,
                "aria-label": (ge = i(s)) == null ? void 0 : ge.decrementValue(Z.type),
                tabindex: "0",
                onKeydown: [
                  fe($e((me) => u(Z.type, !1), ["prevent"]), ["enter"]),
                  fe($e((me) => u(Z.type, !1), ["prevent"]), ["space"])
                ],
                onClick: (me) => u(Z.type, !1)
              }, [
                a.timePickerInline ? ($(), j(ke, { key: 1 }, [
                  mr,
                  pr
                ], 64)) : ($(), j(ke, { key: 0 }, [
                  l.$slots["arrow-down"] ? se(l.$slots, "arrow-down", { key: 0 }) : X("", !0),
                  l.$slots["arrow-down"] ? X("", !0) : ($(), we(i(Wa), { key: 1 }))
                ], 64))
              ], 42, vr)
            ], 64))
          ], 2);
        }), 128)),
        l.is24 ? X("", !0) : ($(), j("div", gr, [
          l.$slots["am-pm-button"] ? se(l.$slots, "am-pm-button", {
            key: 0,
            toggle: R,
            value: S.value
          }) : X("", !0),
          l.$slots["am-pm-button"] ? X("", !0) : ($(), j("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: I,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (x = i(s)) == null ? void 0 : x.amPmButton,
            tabindex: "0",
            onClick: R,
            onKeydown: [
              fe($e(R, ["prevent"]), ["enter"]),
              fe($e(R, ["prevent"]), ["space"])
            ]
          }, Ve(S.value), 41, yr))
        ])),
        ($(!0), j(ke, null, Pe(W.value, (Z, ae) => ($(), we(_t, {
          key: ae,
          name: i(k)(U[Z.type]),
          css: i(_)
        }, {
          default: ye(() => [
            U[Z.type] ? ($(), we(jt, {
              key: 0,
              items: T(Z.type),
              "is-last": l.autoApply && !i(h).keepActionRow,
              "esc-close": l.escClose,
              type: Z.type,
              "text-input": l.textInput,
              config: l.config,
              "arrow-navigation": l.arrowNavigation,
              "aria-labels": l.ariaLabels,
              onSelected: (g) => le(Z.type, g),
              onToggle: (g) => H(Z.type),
              onResetFlow: P[0] || (P[0] = (g) => l.$emit("reset-flow"))
            }, We({
              "button-icon": ye(() => [
                l.$slots["clock-icon"] ? se(l.$slots, "clock-icon", { key: 0 }) : X("", !0),
                l.$slots["clock-icon"] ? X("", !0) : ($(), we(la(l.timePickerInline ? i(Ot) : i(La)), { key: 1 }))
              ]),
              _: 2
            }, [
              l.$slots[`${Z.type}-overlay-value`] ? {
                name: "item",
                fn: ye(({ item: g }) => [
                  se(l.$slots, `${Z.type}-overlay-value`, {
                    text: g.text,
                    value: g.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "onSelected", "onToggle"])) : X("", !0)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), br = { class: "dp--tp-wrap" }, kr = ["aria-label", "tabindex"], wr = ["tabindex"], Mr = ["aria-label"], In = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => !1
    },
    ...tt
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, { buildMatrix: f, setTimePicker: v } = pt(), s = Dt(), { defaultedTransitions: C, defaultedAriaLabels: B, defaultedTextInput: h, defaultedConfig: w, defaultedRange: k } = Re(a), { transitionName: _, showTransition: U } = Ut(C), { hideNavigationButtons: S } = oa(), I = ee(null), b = ee(null), L = ee([]), N = ee(null);
    He(() => {
      n("mount"), !a.timePicker && a.arrowNavigation ? f([Ye(I.value)], "time") : v(!0, a.timePicker);
    });
    const q = Q(() => k.value.enabled && a.modelAuto ? kn(a.internalModelValue) : !0), F = ee(!1), Y = (c) => ({
      hours: Array.isArray(a.hours) ? a.hours[c] : a.hours,
      minutes: Array.isArray(a.minutes) ? a.minutes[c] : a.minutes,
      seconds: Array.isArray(a.seconds) ? a.seconds[c] : a.seconds
    }), K = Q(() => {
      const c = [];
      if (k.value.enabled)
        for (let T = 0; T < 2; T++)
          c.push(Y(T));
      else
        c.push(Y(0));
      return c;
    }), y = (c, T = !1, p = "") => {
      T || n("reset-flow"), F.value = c, n(c ? "overlay-opened" : "overlay-closed"), a.arrowNavigation && v(c), et(() => {
        p !== "" && L.value[0] && L.value[0].openChildCmp(p);
      });
    }, ie = Q(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: a.autoApply && !w.value.keepActionRow
    })), oe = Ge(s, "timePicker"), re = (c, T, p) => k.value.enabled ? T === 0 ? [c, K.value[1][p]] : [K.value[0][p], c] : c, O = (c) => {
      n("update:hours", c);
    }, W = (c) => {
      n("update:minutes", c);
    }, te = (c) => {
      n("update:seconds", c);
    }, V = () => {
      if (N.value && !h.value.enabled && !a.noOverlayFocus) {
        const c = wn(N.value);
        c && c.focus({ preventScroll: !0 });
      }
    };
    return t({ toggleTimePicker: y }), (c, T) => {
      var p;
      return $(), j("div", br, [
        !c.timePicker && !c.timePickerInline ? xt(($(), j("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: I,
          type: "button",
          class: Me(ie.value),
          "aria-label": (p = i(B)) == null ? void 0 : p.openTimePicker,
          tabindex: c.noOverlayFocus ? void 0 : 0,
          "data-test": "open-time-picker-btn",
          onKeydown: [
            T[0] || (T[0] = fe((J) => y(!0), ["enter"])),
            T[1] || (T[1] = fe((J) => y(!0), ["space"]))
          ],
          onClick: T[2] || (T[2] = (J) => y(!0))
        }, [
          c.$slots["clock-icon"] ? se(c.$slots, "clock-icon", { key: 0 }) : X("", !0),
          c.$slots["clock-icon"] ? X("", !0) : ($(), we(i(La), { key: 1 }))
        ], 42, kr)), [
          [ea, !i(S)(c.hideNavigation, "time")]
        ]) : X("", !0),
        Xe(_t, {
          name: i(_)(F.value),
          css: i(U) && !c.timePickerInline
        }, {
          default: ye(() => {
            var J;
            return [
              F.value || c.timePicker || c.timePickerInline ? ($(), j("div", {
                key: 0,
                ref_key: "overlayRef",
                ref: N,
                class: Me({
                  dp__overlay: !c.timePickerInline,
                  "dp--overlay-absolute": !a.timePicker && !c.timePickerInline,
                  "dp--overlay-relative": a.timePicker
                }),
                style: qe(c.timePicker ? { height: `${i(w).modeHeight}px` } : void 0),
                tabindex: c.timePickerInline ? void 0 : 0
              }, [
                ce("div", {
                  class: Me(
                    c.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  c.$slots["time-picker-overlay"] ? se(c.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: O,
                    setMinutes: W,
                    setSeconds: te
                  }) : X("", !0),
                  c.$slots["time-picker-overlay"] ? X("", !0) : ($(), j("div", {
                    key: 1,
                    class: Me(c.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    ($(!0), j(ke, null, Pe(K.value, (E, m) => xt(($(), we(hr, Ne({
                      key: m,
                      ref_for: !0
                    }, {
                      ...c.$props,
                      order: m,
                      hours: E.hours,
                      minutes: E.minutes,
                      seconds: E.seconds,
                      closeTimePickerBtn: b.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: m === 0 ? c.fixedStart : c.fixedEnd
                    }, {
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: L,
                      "validate-time": (H, ne) => e.validateTime(H, re(ne, m, H)),
                      "onUpdate:hours": (H) => O(re(H, m, "hours")),
                      "onUpdate:minutes": (H) => W(re(H, m, "minutes")),
                      "onUpdate:seconds": (H) => te(re(H, m, "seconds")),
                      onMounted: V,
                      onOverlayClosed: V,
                      onAmPmChange: T[3] || (T[3] = (H) => c.$emit("am-pm-change", H))
                    }), We({ _: 2 }, [
                      Pe(i(oe), (H, ne) => ({
                        name: H,
                        fn: ye((u) => [
                          se(c.$slots, H, Ne({ ref_for: !0 }, u))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [ea, m === 0 ? !0 : q.value]
                    ])), 128))
                  ], 2)),
                  !c.timePicker && !c.timePickerInline ? xt(($(), j("button", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: b,
                    type: "button",
                    class: Me(ie.value),
                    "aria-label": (J = i(B)) == null ? void 0 : J.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      T[4] || (T[4] = fe((E) => y(!1), ["enter"])),
                      T[5] || (T[5] = fe((E) => y(!1), ["space"]))
                    ],
                    onClick: T[6] || (T[6] = (E) => y(!1))
                  }, [
                    c.$slots["calendar-icon"] ? se(c.$slots, "calendar-icon", { key: 0 }) : X("", !0),
                    c.$slots["calendar-icon"] ? X("", !0) : ($(), we(i(Ot), { key: 1 }))
                  ], 42, Mr)), [
                    [ea, !i(S)(c.hideNavigation, "time")]
                  ]) : X("", !0)
                ], 2)
              ], 14, wr)) : X("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), Nn = (e, t, r, n) => {
  const { defaultedRange: a } = Re(e), f = (N, q) => Array.isArray(t[N]) ? t[N][q] : t[N], v = (N) => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[N] : t.seconds : 0, s = (N, q) => N ? q !== void 0 ? vt(N, f("hours", q), f("minutes", q), v(q)) : vt(N, t.hours, t.minutes, v()) : Ya(z(), v(q)), C = (N, q) => {
    t[N] = q;
  }, B = Q(() => e.modelAuto && a.value.enabled ? Array.isArray(r.value) ? r.value.length > 1 : !1 : a.value.enabled), h = (N, q) => {
    const F = Object.fromEntries(
      Object.keys(t).map((Y) => Y === N ? [Y, q] : [Y, t[Y]].slice())
    );
    if (B.value && !a.value.disableTimeRangeValidation) {
      const Y = (y) => r.value ? vt(
        r.value[y],
        F.hours[y],
        F.minutes[y],
        F.seconds[y]
      ) : null, K = (y) => Ia(r.value[y], 0);
      return !(be(Y(0), Y(1)) && (St(Y(0), K(1)) || Wt(Y(1), K(0))));
    }
    return !0;
  }, w = (N, q) => {
    h(N, q) && (C(N, q), n && n());
  }, k = (N) => {
    w("hours", N);
  }, _ = (N) => {
    w("minutes", N);
  }, U = (N) => {
    w("seconds", N);
  }, S = (N, q, F, Y) => {
    q && k(N), !q && !F && _(N), F && U(N), r.value && Y(r.value);
  }, I = (N) => {
    if (N) {
      const q = Array.isArray(N), F = q ? [+N[0].hours, +N[1].hours] : +N.hours, Y = q ? [+N[0].minutes, +N[1].minutes] : +N.minutes, K = q ? [+N[0].seconds, +N[1].seconds] : +N.seconds;
      C("hours", F), C("minutes", Y), e.enableSeconds && C("seconds", K);
    }
  }, b = (N, q) => {
    const F = {
      hours: Array.isArray(t.hours) ? t.hours[N] : t.hours,
      disabledArr: []
    };
    return (q || q === 0) && (F.hours = q), Array.isArray(e.disabledTimes) && (F.disabledArr = a.value.enabled && Array.isArray(e.disabledTimes[N]) ? e.disabledTimes[N] : e.disabledTimes), F;
  }, L = Q(() => (N, q) => {
    var F;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: Y, hours: K } = b(N, q), y = Y.filter((ie) => +ie.hours === K);
      return ((F = y[0]) == null ? void 0 : F.minutes) === "*" ? { hours: [K], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (y == null ? void 0 : y.map((ie) => +ie.minutes)) ?? [],
        seconds: (y == null ? void 0 : y.map((ie) => ie.seconds ? +ie.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: C,
    updateHours: k,
    updateMinutes: _,
    updateSeconds: U,
    getSetDateTime: s,
    updateTimeValues: S,
    getSecondsValue: v,
    assignStartTime: I,
    validateTime: h,
    disabledTimesConfig: L
  };
}, Dr = (e, t) => {
  const { modelValue: r, time: n } = Kt(e, t), { defaultedStartTime: a, defaultedRange: f } = Re(e), { updateTimeValues: v, getSetDateTime: s, setTime: C, assignStartTime: B, disabledTimesConfig: h, validateTime: w } = Nn(e, n, r, k);
  function k() {
    t("update-flow-step");
  }
  const _ = (F) => {
    const { hours: Y, minutes: K, seconds: y } = F;
    return { hours: +Y, minutes: +K, seconds: y ? +y : 0 };
  }, U = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const Y = _(e.startTime[0]), K = _(e.startTime[1]);
        return [Ae(z(), Y), Ae(z(), K)];
      }
      const F = _(e.startTime);
      return Ae(z(), F);
    }
    return f.value.enabled ? [null, null] : null;
  }, S = () => {
    if (f.value.enabled) {
      const [F, Y] = U();
      r.value = [s(F, 0), s(Y, 1)];
    } else
      r.value = s(U());
  }, I = (F) => Array.isArray(F) ? [wt(z(F[0])), wt(z(F[1]))] : [wt(F ?? z())], b = (F, Y, K) => {
    C("hours", F), C("minutes", Y), C("seconds", e.enableSeconds ? K : 0);
  }, L = () => {
    const [F, Y] = I(r.value);
    return f.value.enabled ? b(
      [F.hours, Y.hours],
      [F.minutes, Y.minutes],
      [F.seconds, Y.seconds]
    ) : b(F.hours, F.minutes, F.seconds);
  };
  He(() => {
    if (!e.shadow)
      return B(a.value), r.value ? L() : S();
  });
  const N = () => {
    Array.isArray(r.value) ? r.value = r.value.map((F, Y) => F && s(F, Y)) : r.value = s(r.value), t("time-update");
  };
  return {
    modelValue: r,
    time: n,
    disabledTimesConfig: h,
    updateTime: (F, Y = !0, K = !1) => {
      v(F, Y, K, N);
    },
    validateTime: w
  };
}, $r = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...tt
  },
  emits: [
    "update:internal-model-value",
    "time-update",
    "am-pm-change",
    "mount",
    "reset-flow",
    "update-flow-step"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, f = Dt(), v = Ge(f, "timePicker"), s = ee(null), { time: C, modelValue: B, disabledTimesConfig: h, updateTime: w, validateTime: k } = Dr(a, n);
    return He(() => {
      a.shadow || n("mount", null);
    }), t({ getSidebarProps: () => ({
      modelValue: B,
      time: C,
      updateTime: w
    }), toggleTimePicker: (S, I = !1, b = "") => {
      var L;
      (L = s.value) == null || L.toggleTimePicker(S, I, b);
    } }), (S, I) => ($(), we(ua, {
      "multi-calendars": 0,
      stretch: ""
    }, {
      default: ye(() => [
        Xe(In, Ne({
          ref_key: "tpRef",
          ref: s
        }, S.$props, {
          hours: i(C).hours,
          minutes: i(C).minutes,
          seconds: i(C).seconds,
          "internal-model-value": S.internalModelValue,
          "disabled-times-config": i(h),
          "validate-time": i(k),
          "onUpdate:hours": I[0] || (I[0] = (b) => i(w)(b)),
          "onUpdate:minutes": I[1] || (I[1] = (b) => i(w)(b, !1)),
          "onUpdate:seconds": I[2] || (I[2] = (b) => i(w)(b, !1, !0)),
          onAmPmChange: I[3] || (I[3] = (b) => S.$emit("am-pm-change", b)),
          onResetFlow: I[4] || (I[4] = (b) => S.$emit("reset-flow"))
        }), We({ _: 2 }, [
          Pe(i(v), (b, L) => ({
            name: b,
            fn: ye((N) => [
              se(S.$slots, b, Ie(ze(N)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }));
  }
}), Ar = { class: "dp--header-wrap" }, Tr = {
  key: 0,
  class: "dp__month_year_wrap"
}, Sr = { key: 0 }, Pr = { class: "dp__month_year_wrap" }, Rr = ["aria-label", "data-test", "onClick", "onKeydown"], Cr = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...tt
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, {
      defaultedTransitions: f,
      defaultedAriaLabels: v,
      defaultedMultiCalendars: s,
      defaultedFilters: C,
      defaultedConfig: B,
      defaultedHighlight: h,
      propDates: w
    } = Re(a), { transitionName: k, showTransition: _ } = Ut(f), { buildMatrix: U } = pt(), { handleMonthYearChange: S, isDisabled: I, updateMonthYear: b } = Fl(a, n), { showLeftIcon: L, showRightIcon: N } = oa(), q = ee(!1), F = ee(!1), Y = ee([null, null, null, null]);
    He(() => {
      n("mount");
    });
    const K = (m) => ({
      get: () => a[m],
      set: (H) => {
        const ne = m === Je.month ? Je.year : Je.month;
        n("update-month-year", { [m]: H, [ne]: a[ne] }), m === Je.month ? V(!0) : c(!0);
      }
    }), y = Q(K(Je.month)), ie = Q(K(Je.year)), oe = Q(() => (m) => ({
      month: a.month,
      year: a.year,
      items: m === Je.month ? a.months : a.years,
      instance: a.instance,
      updateMonthYear: b,
      toggle: m === Je.month ? V : c
    })), re = Q(() => {
      const m = a.months.find((H) => H.value === a.month);
      return m || { text: "", value: 0 };
    }), O = Q(() => Rt(a.months, (m) => {
      const H = a.month === m.value, ne = Ht(
        m.value,
        Dn(a.year, w.value.minDate),
        $n(a.year, w.value.maxDate)
      ) || C.value.months.includes(m.value), u = Rn(h.value, m.value, a.year);
      return { active: H, disabled: ne, highlighted: u };
    })), W = Q(() => Rt(a.years, (m) => {
      const H = a.year === m.value, ne = Ht(
        m.value,
        Ct(w.value.minDate),
        Ct(w.value.maxDate)
      ) || C.value.years.includes(m.value), u = Ka(h.value, m.value);
      return { active: H, disabled: ne, highlighted: u };
    })), te = (m, H) => {
      H !== void 0 ? m.value = H : m.value = !m.value, m.value || n("overlay-closed");
    }, V = (m = !1, H) => {
      T(m), te(q, H);
    }, c = (m = !1, H) => {
      T(m), te(F, H);
    }, T = (m) => {
      m || n("reset-flow");
    }, p = (m, H) => {
      a.arrowNavigation && (Y.value[H] = Ye(m), U(Y.value, "monthYear"));
    }, J = Q(() => {
      var m, H;
      return [
        {
          type: Je.month,
          index: 1,
          toggle: V,
          modelValue: y.value,
          updateModelValue: (ne) => y.value = ne,
          text: re.value.text,
          showSelectionGrid: q.value,
          items: O.value,
          ariaLabel: (m = v.value) == null ? void 0 : m.openMonthsOverlay
        },
        {
          type: Je.year,
          index: 2,
          toggle: c,
          modelValue: ie.value,
          updateModelValue: (ne) => ie.value = ne,
          text: Mn(a.year, a.locale),
          showSelectionGrid: F.value,
          items: W.value,
          ariaLabel: (H = v.value) == null ? void 0 : H.openYearsOverlay
        }
      ];
    }), E = Q(() => a.disableYearSelect ? [J.value[0]] : a.yearFirst ? [...J.value].reverse() : J.value);
    return t({
      toggleMonthPicker: V,
      toggleYearPicker: c,
      handleMonthYearChange: S
    }), (m, H) => {
      var ne, u, M;
      return $(), j("div", Ar, [
        m.$slots["month-year"] ? ($(), j("div", Tr, [
          se(m.$slots, "month-year", Ie(ze({ month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: i(b), handleMonthYearChange: i(S), instance: e.instance })))
        ])) : ($(), j(ke, { key: 1 }, [
          m.$slots["top-extra"] ? ($(), j("div", Sr, [
            se(m.$slots, "top-extra", { value: m.internalModelValue })
          ])) : X("", !0),
          ce("div", Pr, [
            i(L)(i(s), e.instance) && !m.vertical ? ($(), we(Ft, {
              key: 0,
              "aria-label": (ne = i(v)) == null ? void 0 : ne.prevMonth,
              disabled: i(I)(!1),
              onActivate: H[0] || (H[0] = (R) => i(S)(!1, !0)),
              onSetRef: H[1] || (H[1] = (R) => p(R, 0))
            }, {
              default: ye(() => [
                m.$slots["arrow-left"] ? se(m.$slots, "arrow-left", { key: 0 }) : X("", !0),
                m.$slots["arrow-left"] ? X("", !0) : ($(), we(i(Ea), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : X("", !0),
            ce("div", {
              class: Me(["dp__month_year_wrap", {
                dp__year_disable_select: m.disableYearSelect
              }])
            }, [
              ($(!0), j(ke, null, Pe(E.value, (R, de) => ($(), j(ke, {
                key: R.type
              }, [
                ce("button", {
                  ref_for: !0,
                  ref: (d) => p(d, de + 1),
                  type: "button",
                  class: "dp__btn dp__month_year_select",
                  tabindex: "0",
                  "aria-label": R.ariaLabel,
                  "data-test": `${R.type}-toggle-overlay-${e.instance}`,
                  onClick: R.toggle,
                  onKeydown: [
                    fe($e(R.toggle, ["prevent"]), ["enter"]),
                    fe($e(R.toggle, ["prevent"]), ["space"])
                  ]
                }, [
                  m.$slots[R.type] ? se(m.$slots, R.type, {
                    key: 0,
                    text: R.text,
                    value: a[R.type]
                  }) : X("", !0),
                  m.$slots[R.type] ? X("", !0) : ($(), j(ke, { key: 1 }, [
                    it(Ve(R.text), 1)
                  ], 64))
                ], 40, Rr),
                Xe(_t, {
                  name: i(k)(R.showSelectionGrid),
                  css: i(_)
                }, {
                  default: ye(() => [
                    R.showSelectionGrid ? ($(), we(jt, {
                      key: 0,
                      items: R.items,
                      "arrow-navigation": m.arrowNavigation,
                      "hide-navigation": m.hideNavigation,
                      "is-last": m.autoApply && !i(B).keepActionRow,
                      "skip-button-ref": !1,
                      config: m.config,
                      type: R.type,
                      "header-refs": [],
                      "esc-close": m.escClose,
                      "menu-wrap-ref": m.menuWrapRef,
                      "text-input": m.textInput,
                      "aria-labels": m.ariaLabels,
                      onSelected: R.updateModelValue,
                      onToggle: R.toggle
                    }, We({
                      "button-icon": ye(() => [
                        m.$slots["calendar-icon"] ? se(m.$slots, "calendar-icon", { key: 0 }) : X("", !0),
                        m.$slots["calendar-icon"] ? X("", !0) : ($(), we(i(Ot), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      m.$slots[`${R.type}-overlay-value`] ? {
                        name: "item",
                        fn: ye(({ item: d }) => [
                          se(m.$slots, `${R.type}-overlay-value`, {
                            text: d.text,
                            value: d.value
                          })
                        ]),
                        key: "0"
                      } : void 0,
                      m.$slots[`${R.type}-overlay`] ? {
                        name: "overlay",
                        fn: ye(() => [
                          se(m.$slots, `${R.type}-overlay`, Ne({ ref_for: !0 }, oe.value(R.type)))
                        ]),
                        key: "1"
                      } : void 0,
                      m.$slots[`${R.type}-overlay-header`] ? {
                        name: "header",
                        fn: ye(() => [
                          se(m.$slots, `${R.type}-overlay-header`, {
                            toggle: R.toggle
                          })
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "onSelected", "onToggle"])) : X("", !0)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ], 64))), 128))
            ], 2),
            i(L)(i(s), e.instance) && m.vertical ? ($(), we(Ft, {
              key: 1,
              "aria-label": (u = i(v)) == null ? void 0 : u.prevMonth,
              disabled: i(I)(!1),
              onActivate: H[2] || (H[2] = (R) => i(S)(!1, !0))
            }, {
              default: ye(() => [
                m.$slots["arrow-up"] ? se(m.$slots, "arrow-up", { key: 0 }) : X("", !0),
                m.$slots["arrow-up"] ? X("", !0) : ($(), we(i(Va), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : X("", !0),
            i(N)(i(s), e.instance) ? ($(), we(Ft, {
              key: 2,
              ref: "rightIcon",
              disabled: i(I)(!0),
              "aria-label": (M = i(v)) == null ? void 0 : M.nextMonth,
              onActivate: H[3] || (H[3] = (R) => i(S)(!0, !0)),
              onSetRef: H[4] || (H[4] = (R) => p(R, m.disableYearSelect ? 2 : 3))
            }, {
              default: ye(() => [
                m.$slots[m.vertical ? "arrow-down" : "arrow-right"] ? se(m.$slots, m.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : X("", !0),
                m.$slots[m.vertical ? "arrow-down" : "arrow-right"] ? X("", !0) : ($(), we(la(m.vertical ? i(Wa) : i(Fa)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label"])) : X("", !0)
          ])
        ], 64))
      ]);
    };
  }
}), _r = ["aria-label"], Or = {
  class: "dp__calendar_header",
  role: "row"
}, Br = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, Yr = ["aria-label"], Ir = /* @__PURE__ */ ce("div", { class: "dp__calendar_header_separator" }, null, -1), Nr = ["aria-label"], Er = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, Fr = { class: "dp__cell_inner" }, Lr = ["id", "aria-selected", "aria-disabled", "aria-label", "data-test", "onClick", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"], Vr = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...tt
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, { buildMultiLevelMatrix: f } = pt(), {
      defaultedTransitions: v,
      defaultedConfig: s,
      defaultedAriaLabels: C,
      defaultedMultiCalendars: B,
      defaultedWeekNumbers: h,
      defaultedMultiDates: w
    } = Re(a), k = ee(null), _ = ee({
      bottom: "",
      left: "",
      transform: ""
    }), U = ee([]), S = ee(null), I = ee(!0), b = ee(""), L = ee({ startX: 0, endX: 0, startY: 0, endY: 0 }), N = ee([]), q = ee({ left: "50%" }), F = ee(!1), Y = Q(() => a.calendar ? a.calendar(a.mappedDates) : a.mappedDates), K = Q(() => a.dayNames ? Array.isArray(a.dayNames) ? a.dayNames : a.dayNames(a.locale, +a.weekStart) : rl(a.formatLocale, a.locale, +a.weekStart));
    He(() => {
      n("mount", { cmp: "calendar", refs: U }), s.value.noSwipe || S.value && (S.value.addEventListener("touchstart", J, { passive: !1 }), S.value.addEventListener("touchend", E, { passive: !1 }), S.value.addEventListener("touchmove", m, { passive: !1 })), a.monthChangeOnScroll && S.value && S.value.addEventListener("wheel", u, { passive: !1 });
    });
    const y = (l) => l ? a.vertical ? "vNext" : "next" : a.vertical ? "vPrevious" : "previous", ie = (l, P) => {
      if (a.transitions) {
        const x = Qe(ut(z(), a.month, a.year));
        b.value = Oe(Qe(ut(z(), l, P)), x) ? v.value[y(!0)] : v.value[y(!1)], I.value = !1, et(() => {
          I.value = !0;
        });
      }
    }, oe = Q(
      () => ({
        [a.calendarClassName]: !!a.calendarClassName
      })
    ), re = Q(() => (l) => {
      const P = sl(l);
      return {
        dp__marker_dot: P.type === "dot",
        dp__marker_line: P.type === "line"
      };
    }), O = Q(() => (l) => be(l, k.value)), W = Q(() => ({
      dp__calendar: !0,
      dp__calendar_next: B.value.count > 0 && a.instance !== 0
    })), te = Q(() => (l) => a.hideOffsetDates ? l.current : !0), V = (l) => lt(l, "yyyy-MM-dd"), c = async (l, P, x) => {
      const Z = Ye(U.value[P][x]);
      if (Z) {
        const { width: ae, height: g } = Z.getBoundingClientRect();
        k.value = l.value;
        let A = { left: `${ae / 2}px` }, ge = -50;
        if (await et(), N.value[0]) {
          const { left: me, width: Fe } = N.value[0].getBoundingClientRect();
          me < 0 && (A = { left: "0" }, ge = 0, q.value.left = `${ae / 2}px`), window.innerWidth < me + Fe && (A = { right: "0" }, ge = 0, q.value.left = `${Fe - ae / 2}px`);
        }
        _.value = {
          bottom: `${g}px`,
          ...A,
          transform: `translateX(${ge}%)`
        }, n("tooltip-open", l.marker);
      }
    }, T = async (l, P, x) => {
      var Z, ae;
      if (F.value && w.value.enabled && w.value.dragSelect)
        return n("select-date", l);
      n("set-hover-date", l), (ae = (Z = l.marker) == null ? void 0 : Z.tooltip) != null && ae.length && await c(l, P, x);
    }, p = (l) => {
      k.value && (k.value = null, _.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), n("tooltip-close", l.marker));
    }, J = (l) => {
      L.value.startX = l.changedTouches[0].screenX, L.value.startY = l.changedTouches[0].screenY;
    }, E = (l) => {
      L.value.endX = l.changedTouches[0].screenX, L.value.endY = l.changedTouches[0].screenY, H();
    }, m = (l) => {
      a.vertical && !a.inline && l.preventDefault();
    }, H = () => {
      const l = a.vertical ? "Y" : "X";
      Math.abs(L.value[`start${l}`] - L.value[`end${l}`]) > 10 && n("handle-swipe", L.value[`start${l}`] > L.value[`end${l}`] ? "right" : "left");
    }, ne = (l, P, x) => {
      l && (Array.isArray(U.value[P]) ? U.value[P][x] = l : U.value[P] = [l]), a.arrowNavigation && f(U.value, "calendar");
    }, u = (l) => {
      a.monthChangeOnScroll && (l.preventDefault(), n("handle-scroll", l));
    }, M = (l) => h.value.type === "local" ? Xn(l.value, { weekStartsOn: +a.weekStart }) : h.value.type === "iso" ? Jn(l.value) : typeof h.value.type == "function" ? h.value.type(l.value) : "", R = (l) => {
      const P = l[0];
      return h.value.hideOnOffsetDates ? l.some((x) => x.current) ? M(P) : "" : M(P);
    }, de = (l, P) => {
      w.value.enabled || (ft(l, s.value), n("select-date", P));
    }, d = (l) => {
      ft(l, s.value);
    }, le = (l) => {
      w.value.enabled && w.value.dragSelect ? (F.value = !0, n("select-date", l)) : w.value.enabled && n("select-date", l);
    };
    return t({ triggerTransition: ie }), (l, P) => {
      var x;
      return $(), j("div", {
        class: Me(W.value)
      }, [
        ce("div", {
          ref_key: "calendarWrapRef",
          ref: S,
          role: "grid",
          class: Me(oe.value),
          "aria-label": (x = i(C)) == null ? void 0 : x.calendarWrap
        }, [
          ce("div", Or, [
            l.weekNumbers ? ($(), j("div", Br, Ve(l.weekNumName), 1)) : X("", !0),
            ($(!0), j(ke, null, Pe(K.value, (Z, ae) => {
              var g, A;
              return $(), j("div", {
                key: ae,
                class: "dp__calendar_header_item",
                role: "gridcell",
                "data-test": "calendar-header",
                "aria-label": (A = (g = i(C)) == null ? void 0 : g.weekDay) == null ? void 0 : A.call(g, ae)
              }, [
                l.$slots["calendar-header"] ? se(l.$slots, "calendar-header", {
                  key: 0,
                  day: Z,
                  index: ae
                }) : X("", !0),
                l.$slots["calendar-header"] ? X("", !0) : ($(), j(ke, { key: 1 }, [
                  it(Ve(Z), 1)
                ], 64))
              ], 8, Yr);
            }), 128))
          ]),
          Ir,
          Xe(_t, {
            name: b.value,
            css: !!l.transitions
          }, {
            default: ye(() => {
              var Z;
              return [
                I.value ? ($(), j("div", {
                  key: 0,
                  class: "dp__calendar",
                  role: "rowgroup",
                  "aria-label": ((Z = i(C)) == null ? void 0 : Z.calendarDays) || void 0,
                  onMouseleave: P[1] || (P[1] = (ae) => F.value = !1)
                }, [
                  ($(!0), j(ke, null, Pe(Y.value, (ae, g) => ($(), j("div", {
                    key: g,
                    class: "dp__calendar_row",
                    role: "row"
                  }, [
                    l.weekNumbers ? ($(), j("div", Er, [
                      ce("div", Fr, Ve(R(ae.days)), 1)
                    ])) : X("", !0),
                    ($(!0), j(ke, null, Pe(ae.days, (A, ge) => {
                      var me, Fe, ue;
                      return $(), j("div", {
                        id: V(A.value),
                        ref_for: !0,
                        ref: (Te) => ne(Te, g, ge),
                        key: ge + g,
                        role: "gridcell",
                        class: "dp__calendar_item",
                        "aria-selected": (A.classData.dp__active_date || A.classData.dp__range_start || A.classData.dp__range_start) ?? void 0,
                        "aria-disabled": A.classData.dp__cell_disabled || void 0,
                        "aria-label": (Fe = (me = i(C)) == null ? void 0 : me.day) == null ? void 0 : Fe.call(me, A),
                        tabindex: "0",
                        "data-test": A.value,
                        onClick: $e((Te) => de(Te, A), ["prevent"]),
                        onKeydown: [
                          fe((Te) => l.$emit("select-date", A), ["enter"]),
                          fe((Te) => l.$emit("handle-space", A), ["space"])
                        ],
                        onMouseenter: (Te) => T(A, g, ge),
                        onMouseleave: (Te) => p(A),
                        onMousedown: (Te) => le(A),
                        onMouseup: P[0] || (P[0] = (Te) => F.value = !1)
                      }, [
                        ce("div", {
                          class: Me(["dp__cell_inner", A.classData])
                        }, [
                          l.$slots.day && te.value(A) ? se(l.$slots, "day", {
                            key: 0,
                            day: +A.text,
                            date: A.value
                          }) : X("", !0),
                          l.$slots.day ? X("", !0) : ($(), j(ke, { key: 1 }, [
                            it(Ve(A.text), 1)
                          ], 64)),
                          A.marker && te.value(A) ? ($(), j(ke, { key: 2 }, [
                            l.$slots.marker ? se(l.$slots, "marker", {
                              key: 0,
                              marker: A.marker,
                              day: +A.text,
                              date: A.value
                            }) : ($(), j("div", {
                              key: 1,
                              class: Me(re.value(A.marker)),
                              style: qe(A.marker.color ? { backgroundColor: A.marker.color } : {})
                            }, null, 6))
                          ], 64)) : X("", !0),
                          O.value(A.value) ? ($(), j("div", {
                            key: 3,
                            ref_for: !0,
                            ref_key: "activeTooltip",
                            ref: N,
                            class: "dp__marker_tooltip",
                            style: qe(_.value)
                          }, [
                            (ue = A.marker) != null && ue.tooltip ? ($(), j("div", {
                              key: 0,
                              class: "dp__tooltip_content",
                              onClick: d
                            }, [
                              ($(!0), j(ke, null, Pe(A.marker.tooltip, (Te, Ue) => ($(), j("div", {
                                key: Ue,
                                class: "dp__tooltip_text"
                              }, [
                                l.$slots["marker-tooltip"] ? se(l.$slots, "marker-tooltip", {
                                  key: 0,
                                  tooltip: Te,
                                  day: A.value
                                }) : X("", !0),
                                l.$slots["marker-tooltip"] ? X("", !0) : ($(), j(ke, { key: 1 }, [
                                  ce("div", {
                                    class: "dp__tooltip_mark",
                                    style: qe(Te.color ? { backgroundColor: Te.color } : {})
                                  }, null, 4),
                                  ce("div", null, Ve(Te.text), 1)
                                ], 64))
                              ]))), 128)),
                              ce("div", {
                                class: "dp__arrow_bottom_tp",
                                style: qe(q.value)
                              }, null, 4)
                            ])) : X("", !0)
                          ], 4)) : X("", !0)
                        ], 2)
                      ], 40, Lr);
                    }), 128))
                  ]))), 128))
                ], 40, Nr)) : X("", !0)
              ];
            }),
            _: 3
          }, 8, ["name", "css"])
        ], 10, _r)
      ], 2);
    };
  }
}), sn = (e) => Array.isArray(e), Wr = (e, t, r, n) => {
  const a = ee([]), f = ee(/* @__PURE__ */ new Date()), v = ee(), { modelValue: s, calendars: C, time: B, today: h } = Kt(e, t), {
    defaultedMultiCalendars: w,
    defaultedStartTime: k,
    defaultedRange: _,
    defaultedConfig: U,
    defaultedTz: S,
    propDates: I,
    defaultedMultiDates: b
  } = Re(e), { validateMonthYearInRange: L, isDisabled: N, isDateRangeAllowed: q, checkMinMaxRange: F } = gt(e), { updateTimeValues: Y, getSetDateTime: K, setTime: y, assignStartTime: ie, validateTime: oe, disabledTimesConfig: re } = Nn(e, B, s, n), O = Q(
    () => (o) => C.value[o] ? C.value[o].month : 0
  ), W = Q(
    () => (o) => C.value[o] ? C.value[o].year : 0
  ), te = (o) => !U.value.keepViewOnOffsetClick || o ? !0 : !v.value, V = (o, D, G, ve = !1) => {
    var De, je;
    te(ve) && (C.value[o] || (C.value[o] = { month: 0, year: 0 }), C.value[o].month = an(D) ? (De = C.value[o]) == null ? void 0 : De.month : D, C.value[o].year = an(G) ? (je = C.value[o]) == null ? void 0 : je.year : G);
  }, c = () => {
    e.autoApply && t("select-date");
  };
  mt(
    s,
    (o, D) => {
      JSON.stringify(o) !== JSON.stringify(D) && J();
    },
    { deep: !0 }
  ), He(() => {
    e.shadow || (s.value || (l(), k.value && ie(k.value)), J(!0), e.focusStartDate && e.startDate && l());
  });
  const T = Q(() => {
    var o;
    return (o = e.flow) != null && o.length && !e.partialFlow ? e.flowStep === e.flow.length : !0;
  }), p = () => {
    e.autoApply && T.value && t("auto-apply");
  }, J = (o = !1) => {
    if (s.value)
      return Array.isArray(s.value) ? (a.value = s.value, R(o)) : H(s.value, o);
    if (w.value.count && o && !e.startDate)
      return m(z(), o);
  }, E = () => Array.isArray(s.value) && _.value.enabled ? he(s.value[0]) === he(s.value[1] ?? s.value[0]) : !1, m = (o, D = !1) => {
    if ((!w.value.count || !w.value.static || D) && V(0, he(o), pe(o)), w.value.count && (!w.value.solo || !s.value || E()))
      for (let G = 1; G < w.value.count; G++) {
        const ve = Ae(z(), { month: O.value(G - 1), year: W.value(G - 1) }), De = gn(ve, { months: 1 });
        C.value[G] = { month: he(De), year: pe(De) };
      }
  }, H = (o, D) => {
    m(o), y("hours", xe(o)), y("minutes", rt(o)), y("seconds", Pt(o)), w.value.count && D && le();
  }, ne = (o) => {
    if (w.value.count) {
      if (w.value.solo)
        return 0;
      const D = he(o[0]), G = he(o[1]);
      return Math.abs(G - D) < w.value.count ? 0 : 1;
    }
    return 1;
  }, u = (o, D) => {
    o[1] && _.value.showLastInRange ? m(o[ne(o)], D) : m(o[0], D);
    const G = (ve, De) => [
      ve(o[0]),
      o[1] ? ve(o[1]) : B[De][1]
    ];
    y("hours", G(xe, "hours")), y("minutes", G(rt, "minutes")), y("seconds", G(Pt, "seconds"));
  }, M = (o, D) => {
    if ((_.value.enabled || e.weekPicker) && !b.value.enabled)
      return u(o, D);
    if (b.value.enabled && D) {
      const G = o[o.length - 1];
      return H(G, D);
    }
  }, R = (o) => {
    const D = s.value;
    M(D, o), w.value.count && w.value.solo && le();
  }, de = (o, D) => {
    const G = Ae(z(), { month: O.value(D), year: W.value(D) }), ve = o < 0 ? kt(G, 1) : Vt(G, 1);
    L(he(ve), pe(ve), o < 0, e.preventMinMaxNavigation) && (V(D, he(ve), pe(ve)), t("update-month-year", { instance: D, month: he(ve), year: pe(ve) }), w.value.count && !w.value.solo && d(D), r());
  }, d = (o) => {
    for (let D = o - 1; D >= 0; D--) {
      const G = Vt(Ae(z(), { month: O.value(D + 1), year: W.value(D + 1) }), 1);
      V(D, he(G), pe(G));
    }
    for (let D = o + 1; D <= w.value.count - 1; D++) {
      const G = kt(Ae(z(), { month: O.value(D - 1), year: W.value(D - 1) }), 1);
      V(D, he(G), pe(G));
    }
  }, le = () => {
    if (Array.isArray(s.value) && s.value.length === 2) {
      const o = z(
        z(s.value[1] ? s.value[1] : kt(s.value[0], 1))
      ), [D, G] = [he(s.value[0]), pe(s.value[0])], [ve, De] = [he(s.value[1]), pe(s.value[1])];
      (D !== ve || D === ve && G !== De) && w.value.solo && V(1, he(o), pe(o));
    } else
      s.value && !Array.isArray(s.value) && (V(0, he(s.value), pe(s.value)), m(z()));
  }, l = () => {
    e.startDate && (V(0, he(z(e.startDate)), pe(z(e.startDate))), w.value.count && d(0));
  }, P = (o, D) => {
    if (e.monthChangeOnScroll) {
      const G = (/* @__PURE__ */ new Date()).getTime() - f.value.getTime(), ve = Math.abs(o.deltaY);
      let De = 500;
      ve > 1 && (De = 100), ve > 100 && (De = 0), G > De && (f.value = /* @__PURE__ */ new Date(), de(e.monthChangeOnScroll !== "inverse" ? -o.deltaY : o.deltaY, D));
    }
  }, x = (o, D, G = !1) => {
    e.monthChangeOnArrows && e.vertical === G && Z(o, D);
  }, Z = (o, D) => {
    de(o === "right" ? -1 : 1, D);
  }, ae = (o) => {
    if (I.value.markers)
      return aa(o.value, I.value.markers);
  }, g = (o, D) => {
    switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [o == 0, !0];
      case "fair":
        return [o == 0 || D > o, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, A = (o, D, G, ve) => {
    if (e.sixWeeks && o.length < 6) {
      const De = 6 - o.length, je = (D.getDay() + 7 - ve) % 7, qt = 6 - (G.getDay() + 7 - ve) % 7, [Nt, ha] = g(je, qt);
      for (let yt = 1; yt <= De; yt++)
        if (ha ? !!(yt % 2) == Nt : Nt) {
          const Xt = o[0].days[0], ba = ge(bt(Xt.value, -7), he(D));
          o.unshift({ days: ba });
        } else {
          const Xt = o[o.length - 1], ba = Xt.days[Xt.days.length - 1], Fn = ge(bt(ba.value, 1), he(D));
          o.push({ days: Fn });
        }
    }
    return o;
  }, ge = (o, D) => {
    const G = z(o), ve = [];
    for (let De = 0; De < 7; De++) {
      const je = bt(G, De), It = he(je) !== D;
      ve.push({
        text: e.hideOffsetDates && It ? "" : je.getDate(),
        value: je,
        current: !It,
        classData: {}
      });
    }
    return ve;
  }, me = (o, D) => {
    const G = [], ve = new Date(D, o), De = new Date(D, o + 1, 0), je = e.weekStart, It = Na(ve, { weekStartsOn: je }), qt = (Nt) => {
      const ha = ge(Nt, o);
      if (G.push({ days: ha }), !G[G.length - 1].days.some(
        (yt) => be(Qe(yt.value), Qe(De))
      )) {
        const yt = bt(Nt, 7);
        qt(yt);
      }
    };
    return qt(It), A(G, ve, De, je);
  }, Fe = (o) => {
    const D = vt(z(o.value), B.hours, B.minutes, Ke());
    t("date-update", D), b.value.enabled ? ja(D, s, b.value.limit) : s.value = D, n(), et().then(() => {
      p();
    });
  }, ue = (o) => _.value.noDisabledRange ? An(a.value[0], o).some((G) => N(G)) : !1, Te = () => {
    a.value = s.value ? s.value.slice() : [], a.value.length === 2 && !(_.value.fixedStart || _.value.fixedEnd) && (a.value = []);
  }, Ue = (o, D) => {
    const G = [
      z(o.value),
      bt(z(o.value), +_.value.autoRange)
    ];
    q(G) ? (D && Gt(o.value), a.value = G) : t("invalid-date", o.value);
  }, Gt = (o) => {
    const D = he(z(o)), G = pe(z(o));
    if (V(0, D, G), w.value.count > 0)
      for (let ve = 1; ve < w.value.count; ve++) {
        const De = pl(
          Ae(z(o), { year: O.value(ve - 1), month: W.value(ve - 1) })
        );
        V(ve, De.month, De.year);
      }
  }, da = (o) => {
    if (ue(o.value) || !F(o.value, s.value, _.value.fixedStart ? 0 : 1))
      return t("invalid-date", o.value);
    a.value = Bn(z(o.value), s, t, _);
  }, Bt = (o, D) => {
    if (Te(), _.value.autoRange)
      return Ue(o, D);
    if (_.value.fixedStart || _.value.fixedEnd)
      return da(o);
    a.value[0] ? F(z(o.value), s.value) && !ue(o.value) ? Ce(z(o.value), z(a.value[0])) ? (a.value.unshift(z(o.value)), t("range-end", a.value[0])) : (a.value[1] = z(o.value), t("range-end", a.value[1])) : (e.autoApply && t("auto-apply-invalid", o.value), t("invalid-date", o.value)) : (a.value[0] = z(o.value), t("range-start", a.value[0]));
  }, Ke = (o = !0) => e.enableSeconds ? Array.isArray(B.seconds) ? o ? B.seconds[0] : B.seconds[1] : B.seconds : 0, Yt = (o) => {
    a.value[o] = vt(
      a.value[o],
      B.hours[o],
      B.minutes[o],
      Ke(o !== 1)
    );
  }, ca = () => {
    var o, D;
    a.value[0] && a.value[1] && +((o = a.value) == null ? void 0 : o[0]) > +((D = a.value) == null ? void 0 : D[1]) && (a.value.reverse(), t("range-start", a.value[0]), t("range-end", a.value[1]));
  }, Qt = () => {
    a.value.length && (a.value[0] && !a.value[1] ? Yt(0) : (Yt(0), Yt(1), n()), ca(), s.value = a.value.slice(), ia(a.value, t, e.autoApply, e.modelAuto));
  }, fa = (o, D = !1) => {
    if (N(o.value) || !o.current && e.hideOffsetDates)
      return t("invalid-date", o.value);
    if (v.value = JSON.parse(JSON.stringify(o)), !_.value.enabled)
      return Fe(o);
    sn(B.hours) && sn(B.minutes) && !b.value.enabled && (Bt(o, D), Qt());
  }, va = (o, D) => {
    var ve;
    V(o, D.month, D.year, !0), w.value.count && !w.value.solo && d(o), t("update-month-year", { instance: o, month: D.month, year: D.year }), r(w.value.solo ? o : void 0);
    const G = (ve = e.flow) != null && ve.length ? e.flow[e.flowStep] : void 0;
    !D.fromNav && (G === at.month || G === at.year) && n();
  }, ma = (o, D) => {
    On({
      value: o,
      modelValue: s,
      range: _.value.enabled,
      timezone: D ? void 0 : S.value.timezone
    }), c(), e.multiCalendars && et().then(() => J(!0));
  }, pa = () => {
    _.value.enabled ? s.value && Array.isArray(s.value) && s.value[0] ? s.value = Ce(z(), s.value[0]) ? [z(), s.value[0]] : [s.value[0], z()] : s.value = [z()] : s.value = z(), c();
  }, ga = () => {
    if (Array.isArray(s.value))
      if (b.value.enabled) {
        const o = ya();
        s.value[s.value.length - 1] = K(o);
      } else
        s.value = s.value.map((o, D) => o && K(o, D));
    else
      s.value = K(s.value);
    t("time-update");
  }, ya = () => Array.isArray(s.value) && s.value.length ? s.value[s.value.length - 1] : null;
  return {
    calendars: C,
    modelValue: s,
    month: O,
    year: W,
    time: B,
    disabledTimesConfig: re,
    today: h,
    validateTime: oe,
    getCalendarDays: me,
    getMarker: ae,
    handleScroll: P,
    handleSwipe: Z,
    handleArrow: x,
    selectDate: fa,
    updateMonthYear: va,
    presetDate: ma,
    selectCurrentDate: pa,
    updateTime: (o, D = !0, G = !1) => {
      Y(o, D, G, ga);
    }
  };
}, Hr = { key: 0 }, zr = /* @__PURE__ */ Ee({
  __name: "DatePicker",
  props: {
    ...tt
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, {
      calendars: f,
      month: v,
      year: s,
      modelValue: C,
      time: B,
      disabledTimesConfig: h,
      today: w,
      validateTime: k,
      getCalendarDays: _,
      getMarker: U,
      handleArrow: S,
      handleScroll: I,
      handleSwipe: b,
      selectDate: L,
      updateMonthYear: N,
      presetDate: q,
      selectCurrentDate: F,
      updateTime: Y
    } = Wr(a, n, E, m), K = Dt(), { setHoverDate: y, getDayClassData: ie, clearHoverDate: oe } = Hl(C, a), { defaultedMultiCalendars: re } = Re(a), O = ee([]), W = ee([]), te = ee(null), V = Ge(K, "calendar"), c = Ge(K, "monthYear"), T = Ge(K, "timePicker"), p = (l) => {
      a.shadow || n("mount", l);
    };
    mt(
      f,
      () => {
        a.shadow || setTimeout(() => {
          n("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    );
    const J = Q(() => (l) => _(v.value(l), s.value(l)).map((P) => ({
      ...P,
      days: P.days.map((x) => (x.marker = U(x), x.classData = ie(x), x))
    })));
    function E(l) {
      var P;
      l || l === 0 ? (P = W.value[l]) == null || P.triggerTransition(v.value(l), s.value(l)) : W.value.forEach((x, Z) => x.triggerTransition(v.value(Z), s.value(Z)));
    }
    function m() {
      n("update-flow-step");
    }
    const H = (l, P = !1) => {
      L(l, P), a.spaceConfirm && n("select-date");
    };
    return t({
      clearHoverDate: oe,
      presetDate: q,
      selectCurrentDate: F,
      toggleMonthPicker: (l, P, x = 0) => {
        var Z;
        (Z = O.value[x]) == null || Z.toggleMonthPicker(l, P);
      },
      toggleYearPicker: (l, P, x = 0) => {
        var Z;
        (Z = O.value[x]) == null || Z.toggleYearPicker(l, P);
      },
      toggleTimePicker: (l, P, x) => {
        var Z;
        (Z = te.value) == null || Z.toggleTimePicker(l, P, x);
      },
      handleArrow: S,
      updateMonthYear: N,
      getSidebarProps: () => ({
        modelValue: C,
        month: v,
        year: s,
        time: B,
        updateTime: Y,
        updateMonthYear: N,
        selectDate: L,
        presetDate: q
      }),
      changeMonth: (l) => {
        var P;
        (P = O.value[0]) == null || P.handleMonthYearChange(l, !0);
      },
      changeYear: (l) => {
        N(0, { month: v.value(0), year: s.value(0) + (l ? 1 : -1), fromNav: !0 });
      },
      selectWeekDate: (l) => {
        if (!a.range) {
          const P = C.value ? C.value : w, x = l ? Na(P, { weekStartsOn: 1 }) : vn(P, { weekStartsOn: 1 });
          L({
            value: x,
            current: he(P) === v.value(0),
            text: "",
            classData: {}
          });
        }
      }
    }), (l, P) => ($(), j(ke, null, [
      Xe(ua, {
        "multi-calendars": i(re).count,
        collapse: l.collapse
      }, {
        default: ye(({ instance: x, index: Z }) => [
          l.disableMonthYearSelect ? X("", !0) : ($(), we(Cr, Ne({
            key: 0,
            ref: (ae) => {
              ae && (O.value[Z] = ae);
            },
            months: i(bn)(l.formatLocale, l.locale, l.monthNameFormat),
            years: i(Ha)(l.yearRange, l.locale, l.reverseYears),
            month: i(v)(x),
            year: i(s)(x),
            instance: x
          }, l.$props, {
            onMount: P[0] || (P[0] = (ae) => p(i(Mt).header)),
            onResetFlow: P[1] || (P[1] = (ae) => l.$emit("reset-flow")),
            onUpdateMonthYear: (ae) => i(N)(x, ae),
            onOverlayClosed: P[2] || (P[2] = (ae) => l.$emit("focus-menu"))
          }), We({ _: 2 }, [
            Pe(i(c), (ae, g) => ({
              name: ae,
              fn: ye((A) => [
                se(l.$slots, ae, Ie(ze(A)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          Xe(Vr, Ne({
            ref: (ae) => {
              ae && (W.value[Z] = ae);
            },
            "mapped-dates": J.value(x),
            month: i(v)(x),
            year: i(s)(x),
            instance: x
          }, l.$props, {
            onSelectDate: (ae) => i(L)(ae, x !== 1),
            onHandleSpace: (ae) => H(ae, x !== 1),
            onSetHoverDate: P[3] || (P[3] = (ae) => i(y)(ae)),
            onHandleScroll: (ae) => i(I)(ae, x),
            onHandleSwipe: (ae) => i(b)(ae, x),
            onMount: P[4] || (P[4] = (ae) => p(i(Mt).calendar)),
            onResetFlow: P[5] || (P[5] = (ae) => l.$emit("reset-flow")),
            onTooltipOpen: P[6] || (P[6] = (ae) => l.$emit("tooltip-open", ae)),
            onTooltipClose: P[7] || (P[7] = (ae) => l.$emit("tooltip-close", ae))
          }), We({ _: 2 }, [
            Pe(i(V), (ae, g) => ({
              name: ae,
              fn: ye((A) => [
                se(l.$slots, ae, Ie(ze({ ...A })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse"]),
      l.enableTimePicker ? ($(), j("div", Hr, [
        l.$slots["time-picker"] ? se(l.$slots, "time-picker", Ie(Ne({ key: 0 }, { time: i(B), updateTime: i(Y) }))) : ($(), we(In, Ne({
          key: 1,
          ref_key: "timePickerRef",
          ref: te
        }, l.$props, {
          hours: i(B).hours,
          minutes: i(B).minutes,
          seconds: i(B).seconds,
          "internal-model-value": l.internalModelValue,
          "disabled-times-config": i(h),
          "validate-time": i(k),
          onMount: P[8] || (P[8] = (x) => p(i(Mt).timePicker)),
          "onUpdate:hours": P[9] || (P[9] = (x) => i(Y)(x)),
          "onUpdate:minutes": P[10] || (P[10] = (x) => i(Y)(x, !1)),
          "onUpdate:seconds": P[11] || (P[11] = (x) => i(Y)(x, !1, !0)),
          onResetFlow: P[12] || (P[12] = (x) => l.$emit("reset-flow")),
          onOverlayClosed: P[13] || (P[13] = (x) => l.$emit("time-picker-close")),
          onOverlayOpened: P[14] || (P[14] = (x) => l.$emit("time-picker-open", x)),
          onAmPmChange: P[15] || (P[15] = (x) => l.$emit("am-pm-change", x))
        }), We({ _: 2 }, [
          Pe(i(T), (x, Z) => ({
            name: x,
            fn: ye((ae) => [
              se(l.$slots, x, Ie(ze(ae)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : X("", !0)
    ], 64));
  }
}), Ur = (e, t) => {
  const r = ee(), {
    defaultedMultiCalendars: n,
    defaultedConfig: a,
    defaultedHighlight: f,
    defaultedRange: v,
    propDates: s,
    defaultedFilters: C,
    defaultedMultiDates: B
  } = Re(e), { modelValue: h, year: w, month: k, calendars: _ } = Kt(e, t), { isDisabled: U } = gt(e), { selectYear: S, groupedYears: I, showYearPicker: b, isDisabled: L, toggleYearPicker: N, handleYearSelect: q, handleYear: F } = Yn({
    modelValue: h,
    multiCalendars: n,
    highlight: f,
    calendars: _,
    propDates: s,
    month: k,
    year: w,
    filters: C,
    props: e,
    emit: t
  }), Y = (T, p) => [T, p].map((J) => lt(J, "MMMM", { locale: e.formatLocale })).join("-"), K = Q(() => (T) => h.value ? Array.isArray(h.value) ? h.value.some((p) => Ja(T, p)) : Ja(h.value, T) : !1), y = (T) => {
    if (v.value.enabled) {
      if (Array.isArray(h.value)) {
        const p = be(T, h.value[0]) || be(T, h.value[1]);
        return ra(h.value, r.value, T) && !p;
      }
      return !1;
    }
    return !1;
  }, ie = (T, p) => T.quarter === xa(p) && T.year === pe(p), oe = (T) => typeof f.value == "function" ? f.value({ quarter: xa(T), year: pe(T) }) : !!f.value.quarters.find((p) => ie(p, T)), re = Q(() => (T) => {
    const p = Ae(/* @__PURE__ */ new Date(), { year: w.value(T) });
    return Zn({
      start: xn(p),
      end: el(p)
    }).map((J) => {
      const E = tl(J), m = Za(J), H = U(J), ne = y(E), u = oe(E);
      return {
        text: Y(E, m),
        value: E,
        active: K.value(E),
        highlighted: u,
        disabled: H,
        isBetween: ne
      };
    });
  }), O = (T) => {
    ja(T, h, B.value.limit), t("auto-apply", !0);
  }, W = (T) => {
    h.value = Ga(h, T, t), ia(h.value, t, e.autoApply, e.modelAuto);
  }, te = (T) => {
    h.value = T, t("auto-apply");
  };
  return {
    defaultedConfig: a,
    defaultedMultiCalendars: n,
    groupedYears: I,
    year: w,
    isDisabled: L,
    quarters: re,
    showYearPicker: b,
    modelValue: h,
    setHoverDate: (T) => {
      r.value = T;
    },
    selectYear: S,
    selectQuarter: (T, p, J) => {
      if (!J)
        return _.value[p].month = he(Za(T)), B.value.enabled ? O(T) : v.value.enabled ? W(T) : te(T);
    },
    toggleYearPicker: N,
    handleYearSelect: q,
    handleYear: F
  };
}, Kr = { class: "dp--quarter-items" }, jr = ["data-test", "disabled", "onClick", "onMouseover"], Gr = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...tt
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, f = Dt(), v = Ge(f, "yearMode"), {
      defaultedMultiCalendars: s,
      defaultedConfig: C,
      groupedYears: B,
      year: h,
      isDisabled: w,
      quarters: k,
      modelValue: _,
      showYearPicker: U,
      setHoverDate: S,
      selectQuarter: I,
      toggleYearPicker: b,
      handleYearSelect: L,
      handleYear: N
    } = Ur(a, n);
    return t({ getSidebarProps: () => ({
      modelValue: _,
      year: h,
      selectQuarter: I,
      handleYearSelect: L,
      handleYear: N
    }) }), (F, Y) => ($(), we(ua, {
      "multi-calendars": i(s).count,
      collapse: F.collapse,
      stretch: ""
    }, {
      default: ye(({ instance: K }) => [
        ce("div", {
          class: "dp-quarter-picker-wrap",
          style: qe({ minHeight: `${i(C).modeHeight}px` })
        }, [
          F.$slots["top-extra"] ? se(F.$slots, "top-extra", {
            key: 0,
            value: F.internalModelValue
          }) : X("", !0),
          ce("div", null, [
            Xe(_n, Ne(F.$props, {
              items: i(B)(K),
              instance: K,
              "show-year-picker": i(U)[K],
              year: i(h)(K),
              "is-disabled": (y) => i(w)(K, y),
              onHandleYear: (y) => i(N)(K, y),
              onYearSelect: (y) => i(L)(y, K),
              onToggleYearPicker: (y) => i(b)(K, y == null ? void 0 : y.flow, y == null ? void 0 : y.show)
            }), We({ _: 2 }, [
              Pe(i(v), (y, ie) => ({
                name: y,
                fn: ye((oe) => [
                  se(F.$slots, y, Ie(ze(oe)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          ce("div", Kr, [
            ($(!0), j(ke, null, Pe(i(k)(K), (y, ie) => ($(), j("div", { key: ie }, [
              ce("button", {
                type: "button",
                class: Me(["dp--qr-btn", {
                  "dp--qr-btn-active": y.active,
                  "dp--qr-btn-between": y.isBetween,
                  "dp--qr-btn-disabled": y.disabled,
                  "dp--highlighted": y.highlighted
                }]),
                "data-test": y.value,
                disabled: y.disabled,
                onClick: (oe) => i(I)(y.value, K, y.disabled),
                onMouseover: (oe) => i(S)(y.value)
              }, [
                F.$slots.quarter ? se(F.$slots, "quarter", {
                  key: 0,
                  value: y.value,
                  text: y.text
                }) : ($(), j(ke, { key: 1 }, [
                  it(Ve(y.text), 1)
                ], 64))
              ], 42, jr)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse"]));
  }
}), Qr = ["id", "aria-label"], qr = {
  key: 0,
  class: "dp--menu-load-container"
}, Xr = /* @__PURE__ */ ce("span", { class: "dp--menu-loader" }, null, -1), Jr = [
  Xr
], Zr = {
  key: 0,
  class: "dp__sidebar_left"
}, xr = ["data-test", "onClick", "onKeydown"], eo = {
  key: 2,
  class: "dp__sidebar_right"
}, to = {
  key: 3,
  class: "dp__action_extra"
}, un = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...sa,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: !1 },
    collapse: { type: Boolean, default: !1 },
    getInputRect: { type: Function, default: () => ({}) }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, f = ee(null), v = Q(() => {
      const { openOnTop: g, ...A } = a;
      return {
        ...A,
        flowStep: y.value,
        collapse: a.collapse,
        noOverlayFocus: a.noOverlayFocus,
        menuWrapRef: f.value
      };
    }), { setMenuFocused: s, setShiftKey: C, control: B } = Cn(), h = Dt(), { defaultedTextInput: w, defaultedInline: k, defaultedConfig: _ } = Re(a), U = ee(null), S = ee(0), I = ee(null), b = ee(!1), L = ee(null);
    He(() => {
      if (!a.shadow) {
        b.value = !0, N(), window.addEventListener("resize", N);
        const g = Ye(f);
        if (g && !w.value.enabled && !k.value.enabled && (s(!0), te()), g) {
          const A = (ge) => {
            _.value.allowPreventDefault && ge.preventDefault(), ft(ge, _.value, !0);
          };
          g.addEventListener("pointerdown", A), g.addEventListener("mousedown", A);
        }
      }
    }), na(() => {
      window.removeEventListener("resize", N);
    });
    const N = () => {
      const g = Ye(I);
      g && (S.value = g.getBoundingClientRect().width);
    }, { arrowRight: q, arrowLeft: F, arrowDown: Y, arrowUp: K } = pt(), { flowStep: y, updateFlowStep: ie, childMount: oe, resetFlow: re } = zl(a, n, L), O = Q(() => a.monthPicker ? rr : a.yearPicker ? sr : a.timePicker ? $r : a.quarterPicker ? Gr : zr), W = Q(() => {
      var ge;
      if (_.value.arrowLeft)
        return _.value.arrowLeft;
      const g = (ge = f.value) == null ? void 0 : ge.getBoundingClientRect(), A = a.getInputRect();
      return A.width < S.value && A.left <= ((g == null ? void 0 : g.left) ?? 0) ? `${A.width / 2}px` : "50%";
    }), te = () => {
      const g = Ye(f);
      g && g.focus({ preventScroll: !0 });
    }, V = Q(() => {
      var g;
      return ((g = L.value) == null ? void 0 : g.getSidebarProps()) || {};
    }), c = () => {
      a.openOnTop && n("recalculate-position");
    }, T = Ge(h, "action"), p = Q(() => a.monthPicker || a.yearPicker ? Ge(h, "monthYear") : a.timePicker ? Ge(h, "timePicker") : Ge(h, "shared")), J = Q(() => a.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), E = Q(() => ({
      dp__menu_disabled: a.disabled,
      dp__menu_readonly: a.readonly,
      "dp-menu-loading": a.loading
    })), m = Q(
      () => ({
        dp__menu: !0,
        dp__menu_index: !k.value.enabled,
        dp__relative: k.value.enabled,
        [a.menuClassName]: !!a.menuClassName
      })
    ), H = (g) => {
      ft(g, _.value, !0);
    }, ne = () => {
      a.escClose && n("close-picker");
    }, u = (g) => {
      if (a.arrowNavigation) {
        if (g === "up")
          return K();
        if (g === "down")
          return Y();
        if (g === "left")
          return F();
        if (g === "right")
          return q();
      } else
        g === "left" || g === "up" ? le("handleArrow", "left", 0, g === "up") : le("handleArrow", "right", 0, g === "down");
    }, M = (g) => {
      C(g.shiftKey), !a.disableMonthYearSelect && g.code === "Tab" && g.target.classList.contains("dp__menu") && B.value.shiftKeyInMenu && (g.preventDefault(), ft(g, _.value, !0), n("close-picker"));
    }, R = () => {
      te(), n("time-picker-close");
    }, de = (g) => {
      var A, ge, me;
      (A = L.value) == null || A.toggleTimePicker(!1, !1), (ge = L.value) == null || ge.toggleMonthPicker(!1, !1, g), (me = L.value) == null || me.toggleYearPicker(!1, !1, g);
    }, d = (g, A = 0) => {
      var ge, me, Fe;
      return g === "month" ? (ge = L.value) == null ? void 0 : ge.toggleMonthPicker(!1, !0, A) : g === "year" ? (me = L.value) == null ? void 0 : me.toggleYearPicker(!1, !0, A) : g === "time" ? (Fe = L.value) == null ? void 0 : Fe.toggleTimePicker(!0, !1) : de(A);
    }, le = (g, ...A) => {
      var ge, me;
      (ge = L.value) != null && ge[g] && ((me = L.value) == null || me[g](...A));
    }, l = () => {
      le("selectCurrentDate");
    }, P = (g, A) => {
      le("presetDate", g, A);
    }, x = () => {
      le("clearHoverDate");
    }, Z = (g, A) => {
      le("updateMonthYear", g, A);
    }, ae = (g) => {
      if (M(g), g.key === "Home" || g.key === "End")
        return le("selectWeekDate", g.key === "Home");
      if (g.key === "PageUp" || g.key === "PageDown")
        return g.shiftKey ? le("changeYear", g.key === "PageUp") : le("changeMonth", g.key === "PageUp");
    };
    return t({
      updateMonthYear: Z,
      switchView: d
    }), (g, A) => {
      var ge, me, Fe;
      return $(), j("div", {
        id: g.uid ? `dp-menu-${g.uid}` : void 0,
        ref_key: "dpMenuRef",
        ref: f,
        tabindex: "0",
        role: "dialog",
        "aria-label": (ge = g.ariaLabels) == null ? void 0 : ge.menu,
        class: Me(m.value),
        style: qe({ "--dp-arrow-left": W.value }),
        onMouseleave: x,
        onClick: H,
        onKeydown: [
          fe(ne, ["esc"]),
          A[18] || (A[18] = fe($e((ue) => u("left"), ["prevent"]), ["left"])),
          A[19] || (A[19] = fe($e((ue) => u("up"), ["prevent"]), ["up"])),
          A[20] || (A[20] = fe($e((ue) => u("down"), ["prevent"]), ["down"])),
          A[21] || (A[21] = fe($e((ue) => u("right"), ["prevent"]), ["right"])),
          ae
        ]
      }, [
        (g.disabled || g.readonly) && i(k).enabled || g.loading ? ($(), j("div", {
          key: 0,
          class: Me(E.value)
        }, [
          g.loading ? ($(), j("div", qr, Jr)) : X("", !0)
        ], 2)) : X("", !0),
        !i(k).enabled && !g.teleportCenter ? ($(), j("div", {
          key: 1,
          class: Me(J.value)
        }, null, 2)) : X("", !0),
        ce("div", {
          ref_key: "innerMenuRef",
          ref: I,
          class: Me({
            dp__menu_content_wrapper: ((me = g.presetDates) == null ? void 0 : me.length) || !!g.$slots["left-sidebar"] || !!g.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e.collapse && (((Fe = g.presetDates) == null ? void 0 : Fe.length) || !!g.$slots["left-sidebar"] || !!g.$slots["right-sidebar"])
          }),
          style: qe({ "--dp-menu-width": `${S.value}px` })
        }, [
          g.$slots["left-sidebar"] ? ($(), j("div", Zr, [
            se(g.$slots, "left-sidebar", Ie(ze(V.value)))
          ])) : X("", !0),
          g.presetDates.length ? ($(), j("div", {
            key: 1,
            class: Me({ "dp--preset-dates-collapsed": e.collapse, "dp--preset-dates": !0 })
          }, [
            ($(!0), j(ke, null, Pe(g.presetDates, (ue, Te) => ($(), j(ke, { key: Te }, [
              ue.slot ? se(g.$slots, ue.slot, {
                key: 0,
                presetDate: P,
                label: ue.label,
                value: ue.value
              }) : ($(), j("button", {
                key: 1,
                type: "button",
                style: qe(ue.style || {}),
                class: Me(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e.collapse }]),
                "data-test": ue.testId ?? void 0,
                onClick: $e((Ue) => P(ue.value, ue.noTz), ["prevent"]),
                onKeydown: [
                  fe($e((Ue) => P(ue.value, ue.noTz), ["prevent"]), ["enter"]),
                  fe($e((Ue) => P(ue.value, ue.noTz), ["prevent"]), ["space"])
                ]
              }, Ve(ue.label), 47, xr))
            ], 64))), 128))
          ], 2)) : X("", !0),
          ce("div", {
            ref_key: "calendarWrapperRef",
            ref: U,
            class: "dp__instance_calendar",
            role: "document"
          }, [
            ($(), we(la(O.value), Ne({
              ref_key: "dynCmpRef",
              ref: L
            }, v.value, {
              "flow-step": i(y),
              onMount: i(oe),
              onUpdateFlowStep: i(ie),
              onResetFlow: i(re),
              onFocusMenu: te,
              onSelectDate: A[0] || (A[0] = (ue) => g.$emit("select-date")),
              onDateUpdate: A[1] || (A[1] = (ue) => g.$emit("date-update", ue)),
              onTooltipOpen: A[2] || (A[2] = (ue) => g.$emit("tooltip-open", ue)),
              onTooltipClose: A[3] || (A[3] = (ue) => g.$emit("tooltip-close", ue)),
              onAutoApply: A[4] || (A[4] = (ue) => g.$emit("auto-apply", ue)),
              onRangeStart: A[5] || (A[5] = (ue) => g.$emit("range-start", ue)),
              onRangeEnd: A[6] || (A[6] = (ue) => g.$emit("range-end", ue)),
              onInvalidFixedRange: A[7] || (A[7] = (ue) => g.$emit("invalid-fixed-range", ue)),
              onTimeUpdate: A[8] || (A[8] = (ue) => g.$emit("time-update")),
              onAmPmChange: A[9] || (A[9] = (ue) => g.$emit("am-pm-change", ue)),
              onTimePickerOpen: A[10] || (A[10] = (ue) => g.$emit("time-picker-open", ue)),
              onTimePickerClose: R,
              onRecalculatePosition: c,
              onUpdateMonthYear: A[11] || (A[11] = (ue) => g.$emit("update-month-year", ue)),
              onAutoApplyInvalid: A[12] || (A[12] = (ue) => g.$emit("auto-apply-invalid", ue)),
              onInvalidDate: A[13] || (A[13] = (ue) => g.$emit("invalid-date", ue)),
              "onUpdate:internalModelValue": A[14] || (A[14] = (ue) => g.$emit("update:internal-model-value", ue))
            }), We({ _: 2 }, [
              Pe(p.value, (ue, Te) => ({
                name: ue,
                fn: ye((Ue) => [
                  se(g.$slots, ue, Ie(ze({ ...Ue })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          g.$slots["right-sidebar"] ? ($(), j("div", eo, [
            se(g.$slots, "right-sidebar", Ie(ze(V.value)))
          ])) : X("", !0),
          g.$slots["action-extra"] ? ($(), j("div", to, [
            g.$slots["action-extra"] ? se(g.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: l
            }) : X("", !0)
          ])) : X("", !0)
        ], 6),
        !g.autoApply || i(_).keepActionRow ? ($(), we(Xl, Ne({
          key: 2,
          "menu-mount": b.value
        }, v.value, {
          "calendar-width": S.value,
          onClosePicker: A[15] || (A[15] = (ue) => g.$emit("close-picker")),
          onSelectDate: A[16] || (A[16] = (ue) => g.$emit("select-date")),
          onInvalidSelect: A[17] || (A[17] = (ue) => g.$emit("invalid-select")),
          onSelectNow: l
        }), We({ _: 2 }, [
          Pe(i(T), (ue, Te) => ({
            name: ue,
            fn: ye((Ue) => [
              se(g.$slots, ue, Ie(ze({ ...Ue })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : X("", !0)
      ], 46, Qr);
    };
  }
}), ao = typeof window < "u" ? window : void 0, Ca = () => {
}, no = (e) => Wn() ? (Hn(e), !0) : !1, lo = (e, t, r, n) => {
  if (!e)
    return Ca;
  let a = Ca;
  const f = mt(
    () => i(e),
    (s) => {
      a(), s && (s.addEventListener(t, r, n), a = () => {
        s.removeEventListener(t, r, n), a = Ca;
      });
    },
    { immediate: !0, flush: "post" }
  ), v = () => {
    f(), a();
  };
  return no(v), v;
}, ro = (e, t, r, n = {}) => {
  const { window: a = ao, event: f = "pointerdown" } = n;
  return a ? lo(a, f, (s) => {
    const C = Ye(e), B = Ye(t);
    !C || !B || C === s.target || s.composedPath().includes(C) || s.composedPath().includes(B) || r(s);
  }, { passive: !0 }) : void 0;
}, oo = /* @__PURE__ */ Ee({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...sa
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date"
  ],
  setup(e, { expose: t, emit: r }) {
    const n = r, a = e, f = Dt(), v = ee(!1), s = Lt(a, "modelValue"), C = Lt(a, "timezone"), B = ee(null), h = ee(null), w = ee(null), k = ee(!1), _ = ee(null), U = ee(!1), S = ee(!1), I = ee(!1), { setMenuFocused: b, setShiftKey: L } = Cn(), { clearArrowNav: N } = pt(), { validateDate: q, isValidTime: F } = gt(a), {
      defaultedTransitions: Y,
      defaultedTextInput: K,
      defaultedInline: y,
      defaultedConfig: ie,
      defaultedRange: oe,
      defaultedMultiDates: re
    } = Re(a), { menuTransition: O, showTransition: W } = Ut(Y);
    He(() => {
      u(a.modelValue), et().then(() => {
        if (!y.value.enabled) {
          const o = E(_.value);
          o == null || o.addEventListener("scroll", ae), window == null || window.addEventListener("resize", g);
        }
      }), y.value.enabled && (v.value = !0), window == null || window.addEventListener("keyup", A), window == null || window.addEventListener("keydown", ge);
    }), na(() => {
      if (!y.value.enabled) {
        const o = E(_.value);
        o == null || o.removeEventListener("scroll", ae), window == null || window.removeEventListener("resize", g);
      }
      window == null || window.removeEventListener("keyup", A), window == null || window.removeEventListener("keydown", ge);
    });
    const te = Ge(f, "all", a.presetDates), V = Ge(f, "input");
    mt(
      [s, C],
      () => {
        u(s.value);
      },
      { deep: !0 }
    );
    const { openOnTop: c, menuStyle: T, xCorrect: p, setMenuPosition: J, getScrollableParent: E, shadowRender: m } = Ll({
      menuRef: B,
      menuRefInner: h,
      inputRef: w,
      pickerWrapperRef: _,
      inline: y,
      emit: n,
      props: a,
      slots: f
    }), {
      inputValue: H,
      internalModelValue: ne,
      parseExternalModelValue: u,
      emitModelValue: M,
      formatInputValue: R,
      checkBeforeEmit: de
    } = El(n, a, k), d = Q(
      () => ({
        dp__main: !0,
        dp__theme_dark: a.dark,
        dp__theme_light: !a.dark,
        dp__flex_display: y.value.enabled,
        "dp--flex-display-collapsed": I.value,
        dp__flex_display_with_input: y.value.input
      })
    ), le = Q(() => a.dark ? "dp__theme_dark" : "dp__theme_light"), l = Q(() => a.teleport ? {
      to: typeof a.teleport == "boolean" ? "body" : a.teleport,
      disabled: !a.teleport || y.value.enabled
    } : {}), P = Q(() => ({ class: "dp__outer_menu_wrap" })), x = Q(() => y.value.enabled && (a.timePicker || a.monthPicker || a.yearPicker || a.quarterPicker)), Z = () => {
      var o, D;
      return (D = (o = w.value) == null ? void 0 : o.$el) == null ? void 0 : D.getBoundingClientRect();
    }, ae = () => {
      v.value && (ie.value.closeOnScroll ? Ke() : J());
    }, g = () => {
      var D;
      v.value && J();
      const o = (D = h.value) == null ? void 0 : D.$el.getBoundingClientRect().width;
      I.value = document.body.offsetWidth <= o;
    }, A = (o) => {
      o.key === "Tab" && !y.value.enabled && !a.teleport && ie.value.tabOutClosesMenu && (_.value.contains(document.activeElement) || Ke()), S.value = o.shiftKey;
    }, ge = (o) => {
      S.value = o.shiftKey;
    }, me = () => {
      !a.disabled && !a.readonly && (m(un, a), J(!1), v.value = !0, v.value && n("open"), v.value || Bt(), u(a.modelValue));
    }, Fe = () => {
      var o;
      H.value = "", Bt(), (o = w.value) == null || o.setParsedDate(null), n("update:model-value", null), n("update:model-timezone-value", null), n("cleared"), ie.value.closeOnClearValue && Ke();
    }, ue = () => {
      const o = ne.value;
      return !o || !Array.isArray(o) && q(o) ? !0 : Array.isArray(o) ? re.value.enabled || o.length === 2 && q(o[0]) && q(o[1]) ? !0 : oe.value.partialRange && !a.timePicker ? q(o[0]) : !1 : !1;
    }, Te = () => {
      de() && ue() ? (M(), Ke()) : n("invalid-select", ne.value);
    }, Ue = (o) => {
      Gt(), M(), ie.value.closeOnAutoApply && !o && Ke();
    }, Gt = () => {
      w.value && K.value.enabled && w.value.setParsedDate(ne.value);
    }, da = (o = !1) => {
      a.autoApply && F(ne.value) && ue() && (oe.value.enabled && Array.isArray(ne.value) ? (oe.value.partialRange || ne.value.length === 2) && Ue(o) : Ue(o));
    }, Bt = () => {
      K.value.enabled || (ne.value = null);
    }, Ke = () => {
      y.value.enabled || (v.value && (v.value = !1, p.value = !1, b(!1), L(!1), N(), n("closed"), H.value && u(s.value)), Bt(), n("blur"));
    }, Yt = (o, D, G = !1) => {
      if (!o) {
        ne.value = null;
        return;
      }
      const ve = Array.isArray(o) ? !o.some((je) => !q(je)) : q(o), De = F(o);
      ve && De && (ne.value = o, D && (U.value = G, Te(), n("text-submit")));
    }, ca = () => {
      a.autoApply && F(ne.value) && M(), Gt();
    }, Qt = () => v.value ? Ke() : me(), fa = (o) => {
      ne.value = o;
    }, va = () => {
      K.value.enabled && (k.value = !0, R()), n("focus");
    }, ma = () => {
      if (K.value.enabled && (k.value = !1, u(a.modelValue), U.value)) {
        const o = dl(_.value, S.value);
        o == null || o.focus();
      }
      n("blur");
    }, pa = (o) => {
      h.value && h.value.updateMonthYear(0, {
        month: tn(o.month),
        year: tn(o.year)
      });
    }, ga = (o) => {
      u(o ?? a.modelValue);
    }, ya = (o, D) => {
      var G;
      (G = h.value) == null || G.switchView(o, D);
    }, Qa = (o) => ie.value.onClickOutside ? ie.value.onClickOutside(o) : Ke();
    return ro(B, w, () => Qa(ue)), t({
      closeMenu: Ke,
      selectDate: Te,
      clearValue: Fe,
      openMenu: me,
      onScroll: ae,
      formatInputValue: R,
      // exposed for testing purposes
      updateInternalModelValue: fa,
      // modify internal modelValue
      setMonthYear: pa,
      parseModel: ga,
      switchView: ya,
      toggleMenu: Qt
    }), (o, D) => ($(), j("div", {
      ref_key: "pickerWrapperRef",
      ref: _,
      class: Me(d.value),
      "data-datepicker-instance": ""
    }, [
      Xe(Gl, Ne({
        ref_key: "inputRef",
        ref: w,
        "input-value": i(H),
        "onUpdate:inputValue": D[0] || (D[0] = (G) => Xa(H) ? H.value = G : null),
        "is-menu-open": v.value
      }, o.$props, {
        onClear: Fe,
        onOpen: me,
        onSetInputDate: Yt,
        onSetEmptyDate: i(M),
        onSelectDate: Te,
        onToggle: Qt,
        onClose: Ke,
        onFocus: va,
        onBlur: ma,
        onRealBlur: D[1] || (D[1] = (G) => k.value = !1)
      }), We({ _: 2 }, [
        Pe(i(V), (G, ve) => ({
          name: G,
          fn: ye((De) => [
            se(o.$slots, G, Ie(ze(De)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      ($(), we(la(o.teleport ? zn : "div"), Ie(ze(l.value)), {
        default: ye(() => [
          Xe(_t, {
            name: i(O)(i(c)),
            css: i(W) && !i(y).enabled
          }, {
            default: ye(() => [
              v.value ? ($(), j("div", Ne({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: B
              }, P.value, {
                class: { "dp--menu-wrapper": !i(y).enabled },
                style: i(y).enabled ? void 0 : i(T)
              }), [
                Xe(un, Ne({
                  ref_key: "dpMenuRef",
                  ref: h
                }, o.$props, {
                  "internal-model-value": i(ne),
                  "onUpdate:internalModelValue": D[2] || (D[2] = (G) => Xa(ne) ? ne.value = G : null),
                  class: { [le.value]: !0, "dp--menu-wrapper": o.teleport },
                  "open-on-top": i(c),
                  "no-overlay-focus": x.value,
                  collapse: I.value,
                  "get-input-rect": Z,
                  onClosePicker: Ke,
                  onSelectDate: Te,
                  onAutoApply: da,
                  onTimeUpdate: ca,
                  onFlowStep: D[3] || (D[3] = (G) => o.$emit("flow-step", G)),
                  onUpdateMonthYear: D[4] || (D[4] = (G) => o.$emit("update-month-year", G)),
                  onInvalidSelect: D[5] || (D[5] = (G) => o.$emit("invalid-select", i(ne))),
                  onAutoApplyInvalid: D[6] || (D[6] = (G) => o.$emit("invalid-select", G)),
                  onInvalidFixedRange: D[7] || (D[7] = (G) => o.$emit("invalid-fixed-range", G)),
                  onRecalculatePosition: i(J),
                  onTooltipOpen: D[8] || (D[8] = (G) => o.$emit("tooltip-open", G)),
                  onTooltipClose: D[9] || (D[9] = (G) => o.$emit("tooltip-close", G)),
                  onTimePickerOpen: D[10] || (D[10] = (G) => o.$emit("time-picker-open", G)),
                  onTimePickerClose: D[11] || (D[11] = (G) => o.$emit("time-picker-close", G)),
                  onAmPmChange: D[12] || (D[12] = (G) => o.$emit("am-pm-change", G)),
                  onRangeStart: D[13] || (D[13] = (G) => o.$emit("range-start", G)),
                  onRangeEnd: D[14] || (D[14] = (G) => o.$emit("range-end", G)),
                  onDateUpdate: D[15] || (D[15] = (G) => o.$emit("date-update", G)),
                  onInvalidDate: D[16] || (D[16] = (G) => o.$emit("invalid-date", G))
                }), We({ _: 2 }, [
                  Pe(i(te), (G, ve) => ({
                    name: G,
                    fn: ye((De) => [
                      se(o.$slots, G, Ie(ze({ ...De })))
                    ])
                  }))
                ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "onRecalculatePosition"])
              ], 16)) : X("", !0)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 3
      }, 16))
    ], 2));
  }
}), En = /* @__PURE__ */ (() => {
  const e = oo;
  return e.install = (t) => {
    t.component("Vue3DatePicker", e);
  }, e;
})(), so = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: En
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(so).forEach(([e, t]) => {
  e !== "default" && (En[e] = t);
});
export {
  En as default
};
